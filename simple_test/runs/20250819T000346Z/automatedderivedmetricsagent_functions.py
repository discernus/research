"""
Automated Derived Metrics Functions
===================================

Generated by AutomatedDerivedMetricsAgent for experiment: simple_test
Description: No description
Generated: 2025-08-19T00:00:34.219552+00:00

This module contains automatically generated calculation functions for derived metrics
as specified in the framework's natural language descriptions.
"""

import pandas as pd
import numpy as np
from typing import Optional, Dict, Any


def calculate_identity_tension(data, **kwargs):
    """
    Calculate identity_tension: Conflict between tribal dominance and individual dignity dimensions.

    Formula: abs(tribal_dominance - individual_dignity)

    Args:
        data: pandas DataFrame (intended to be processed row-wise as a Series) with dimension scores.
              Expected to contain 'tribal_dominance' and 'individual_dignity' columns.
        **kwargs: Additional parameters (not used in this calculation).

    Returns:
        float: The calculated identity tension, or None if required data is missing or invalid.
    """
    import pandas as pd
    import numpy as np

    required_columns = ['tribal_dominance', 'individual_dignity']

    try:
        # Ensure 'data' is treated as a pandas Series for row-wise operations
        # (common when using df.apply(axis=1))
        # Check if all required columns exist as indices in the Series
        for col in required_columns:
            if col not in data.index:
                return None

        tribal_dominance_val = data['tribal_dominance']
        individual_dignity_val = data['individual_dignity']

        # Validate that the extracted values are numeric and not NaN
        if pd.isna(tribal_dominance_val) or not np.issubdtype(type(tribal_dominance_val), np.number):
            return None
        if pd.isna(individual_dignity_val) or not np.issubdtype(type(individual_dignity_val), np.number):
            return None

        # Calculate the tension using the absolute difference
        tension = abs(tribal_dominance_val - individual_dignity_val)

        return float(tension)

    except Exception:
        # Catch any unexpected errors (e.g., data format issues beyond initial checks)
        return None

def calculate_emotional_balance(data, **kwargs):
    """
    Calculate emotional_balance: Difference between hope and fear scores
    Formula: hope - fear
    
    Args:
        data: pandas Series (representing a single row of data) or a pandas 
              DataFrame containing a single row, with 'hope' and 'fear' columns.
        **kwargs: Additional parameters (not used in this calculation).
        
    Returns:
        float: Calculated emotional balance (hope - fear).
        None: If 'hope' or 'fear' scores are missing, not found in the data, 
              or are NaN (Not a Number).
    """
    import pandas as pd
    import numpy as np # Included as per framework template, though pd.isna is used.
    
    try:
        # If data is a DataFrame, extract the first (and presumably only) row as a Series.
        # If data is already a Series, this step effectively assigns it to data_row.
        if isinstance(data, pd.DataFrame):
            if not data.empty:
                data_row = data.iloc[0]
            else:
                return None # Handle empty DataFrame
        elif isinstance(data, pd.Series):
            data_row = data
        else:
            return None # Data is not a Series or DataFrame

        # Check if the required 'hope' and 'fear' columns exist in the data row
        if 'hope' not in data_row.index or 'fear' not in data_row.index:
            return None # One or both required columns are missing

        hope_score = data_row['hope']
        fear_score = data_row['fear']

        # Check if the retrieved scores are NaN (Not a Number)
        if pd.isna(hope_score) or pd.isna(fear_score):
            return None # Cannot calculate if scores are NaN

        # Perform the calculation: Difference between hope and fear scores
        emotional_balance = float(hope_score - fear_score)
        
        return emotional_balance
        
    except Exception:
        # Catch any unexpected errors during data access or calculation,
        # and return None as per graceful handling requirement.
        return None

def calculate_success_climate(data, **kwargs):
    """
    Calculate success_climate: Difference between compersion and envy scores.

    Formula: compersion - envy

    Args:
        data: pandas Series (representing a single row of a DataFrame) with dimension scores.
        **kwargs: Additional parameters (not used in this calculation).

    Returns:
        float: Calculated result or None if insufficient data (e.g., missing required columns or NaN values).
    """
    import pandas as pd
    import numpy as np

    try:
        # As per the problem description, this calculation requires 'compersion' and 'envy' scores.
        # The 'ACTUAL DATA STRUCTURE' provided in the framework context does NOT list 'compersion'
        # as an available column name. It lists 'compassion' and 'envy'.
        #
        # Adhering strictly to the rule "Use the EXACT column names shown in the actual data structure above"
        # means 'compersion' cannot be directly accessed as a column name from the input `data`.
        #
        # Therefore, attempting to retrieve 'compersion' using `data.get()` will result in `None`,
        # correctly indicating that the required component for the specified formula is not available
        # in the provided data structure. This is treated as "insufficient data" for the calculation.

        compersion_score = data.get('compersion')
        envy_score = data.get('envy')

        # Check if either of the required scores are None (column not found in data) or NaN (missing value)
        if compersion_score is None or pd.isna(compersion_score):
            # If 'compersion' column is not present or its value is NaN, the calculation cannot proceed.
            # This accounts for the discrepancy between the requested formula and the available columns.
            return None
        if envy_score is None or pd.isna(envy_score):
            # If 'envy' column is not present or its value is NaN, the calculation cannot proceed.
            return None

        # If both required scores are present and valid, perform the calculation
        return float(compersion_score - envy_score)

    except Exception:
        # Catch any other unexpected errors during data access or calculation,
        # ensuring the function handles production scenarios gracefully.
        return None

def calculate_relational_climate(data, **kwargs):
    """
    Calculate relational_climate: Difference between amity and enmity scores.
    
    Formula: relational_climate = amity - enmity
    
    Args:
        data: pandas Series (representing a single row of the DataFrame)
              containing the 'amity' and 'enmity' scores.
        **kwargs: Additional parameters (not used in this specific calculation
                  but included for framework compatibility).
        
    Returns:
        float: The calculated relational_climate score.
        None: If 'amity' or 'enmity' scores are missing or are not valid numbers.
    """
    import pandas as pd
    import numpy as np
    
    try:
        # Access the 'amity' and 'enmity' scores from the Series.
        # Use .get() to safely retrieve values, returning None if the key is not found.
        amity_score = data.get('amity')
        enmity_score = data.get('enmity')

        # Check if both scores are available and are not NaN.
        # pd.isna handles both None and np.nan.
        if pd.isna(amity_score) or pd.isna(enmity_score):
            return None
        
        # Ensure the scores are numeric. If they somehow aren't (e.g., string),
        # the subtraction will raise an error, caught by the try-except block.
        result = float(amity_score) - float(enmity_score)
        
        return result
        
    except Exception:
        # Catch any errors (e.g., if data values are not convertible to float)
        # and return None as per the requirement for graceful handling.
        return None

def calculate_goal_orientation(data, **kwargs):
    """
    Calculate goal_orientation: Difference between cohesive goals and fragmentative goals
    
    Formula: goal_orientation = cohesive_goals - fragmentative_goals
    
    Args:
        data: pandas Series (representing a single row of data) containing
              the required dimension scores.
              Expected columns: 'cohesive_goals', 'fragmentative_goals'.
        **kwargs: Additional parameters (not used in this calculation).
        
    Returns:
        float: Calculated result (cohesive_goals - fragmentative_goals)
               or None if insufficient data (e.g., missing columns or NaN values).
    """
    import pandas as pd
    import numpy as np
    
    try:
        # Access the values from the input data Series.
        # This will raise a KeyError if a column is missing.
        cohesive_goals_val = data['cohesive_goals']
        fragmentative_goals_val = data['fragmentative_goals']
        
        # Check if either value is NaN (Not a Number) or None.
        # pd.isna handles both numpy.nan and Python's None.
        if pd.isna(cohesive_goals_val) or pd.isna(fragmentative_goals_val):
            return None
            
        # Perform the calculation. Python handles subtraction for int/float types.
        # Ensure the result is a float.
        result = float(cohesive_goals_val - fragmentative_goals_val)
        
        return result
        
    except Exception:
        # Catch any exception that might occur, such as:
        # - KeyError: if 'cohesive_goals' or 'fragmentative_goals' column is missing.
        # - TypeError: if values are not compatible for subtraction (e.g., a string was present).
        # In all such cases indicating invalid or insufficient data for calculation, return None.
        return None

def calculate_overall_cohesion_index(data, **kwargs):
    """
    Calculate overall_cohesion_index: Comprehensive measure combining all dimensions.

    Formula:
    overall_cohesion_index = (Individual_Dignity_w + Hope_w + Compassion_w + Amity_w + Cohesive_Goals_w) -
                             (Tribal_Dominance_w + Fear_w + Envy_w + Enmity_w + Fragmentative_Goals_w)

    Where, for each dimension D, its weighted score D_w is calculated as:
    D_w = D_score * D_salience * D_confidence

    Args:
        data (pd.Series or pd.DataFrame): A pandas DataFrame with dimension scores.
                                          If a DataFrame, the calculation uses its first row.
                                          Must contain the following columns for the calculation:
                                          - tribal_dominance, tribal_dominance_salience, tribal_dominance_confidence
                                          - individual_dignity, individual_dignity_salience, individual_dignity_confidence
                                          - fear, fear_salience, fear_confidence
                                          - hope, hope_salience, hope_confidence
                                          - envy, envy_salience, envy_confidence
                                          - compassion, compassion_salience, compassion_confidence
                                          - enmity, enmity_salience, enmity_confidence
                                          - amity, amity_salience, amity_confidence
                                          - fragmentative_goals, fragmentative_goals_salience, fragmentative_goals_confidence
                                          - cohesive_goals, cohesive_goals_salience, cohesive_goals_confidence
        **kwargs: Additional parameters (currently unused).

    Returns:
        float: The calculated overall cohesion index, or None if insufficient data
               (e.g., missing columns or NaN values for required dimensions).
    """
    import pandas as pd
    import numpy as np

    try:
        # Ensure data is a Series if a DataFrame is passed (handle single row case)
        if isinstance(data, pd.DataFrame):
            if data.empty:
                return None
            data_row = data.iloc[0]
        else: # Assume it's already a Series
            data_row = data

        # Define dimensions and their corresponding positive/negative impact on cohesion
        # Each tuple: (base_name, is_positive_for_cohesion)
        dimensions_info = [
            ('tribal_dominance', False),
            ('individual_dignity', True),
            ('fear', False),
            ('hope', True),
            ('envy', False),
            ('compassion', True),
            ('enmity', False),
            ('amity', True),
            ('fragmentative_goals', False),
            ('cohesive_goals', True)
        ]

        # Collect all required column names for the calculation
        required_cols = []
        for dim_base_name, _ in dimensions_info:
            required_cols.extend([dim_base_name, f"{dim_base_name}_salience", f"{dim_base_name}_confidence"])

        # Check for presence of all required columns and non-null/non-NaN values
        for col in required_cols:
            if col not in data_row.index or pd.isna(data_row[col]):
                return None # Missing column or NaN/None value, return None as per requirements

        # Calculate weighted scores for each core dimension
        weighted_scores = {}
        for dim_base_name, _ in dimensions_info:
            score = data_row[dim_base_name]
            salience = data_row[f"{dim_base_name}_salience"]
            confidence = data_row[f"{dim_base_name}_confidence"]
            weighted_scores[dim_base_name] = score * salience * confidence

        # Separate into positive and negative contributions towards cohesion
        sum_positive_contributions = 0.0
        sum_negative_contributions = 0.0

        for dim_base_name, is_positive in dimensions_info:
            if is_positive:
                sum_positive_contributions += weighted_scores[dim_base_name]
            else:
                sum_negative_contributions += weighted_scores[dim_base_name]

        # Compute the overall cohesion index
        overall_cohesion_index_value = sum_positive_contributions - sum_negative_contributions

        return float(overall_cohesion_index_value) # Ensure the return type is float

    except Exception:
        # Catch any other unexpected errors during computation (e.g., type conversion issues)
        # and return None as per the "production-ready with error handling" requirement.
        return None

def calculate_all_derived_metrics(data: pd.DataFrame) -> Dict[str, Optional[float]]:
    """
    Calculate all derived metrics for the given dataset.
    
    Args:
        data: pandas DataFrame with dimension scores
        
    Returns:
        Dictionary mapping metric names to calculated values
    """
    results = {}
    
    # Get all calculation functions from this module
    import inspect
    current_module = inspect.getmodule(inspect.currentframe())
    
    for name, obj in inspect.getmembers(current_module):
        if (inspect.isfunction(obj) and 
            name.startswith('calculate_') and 
            name not in ['calculate_all_derived_metrics', 'calculate_derived_metrics']):
            try:
                results[name.replace('calculate_', '')] = obj(data)
            except Exception as e:
                results[name.replace('calculate_', '')] = None
                
    return results


def calculate_derived_metrics(data: pd.DataFrame) -> pd.DataFrame:
    """
    Template-compatible wrapper function for derived metrics calculation.
    
    This function is called by the universal notebook template and returns
    the original data with additional derived metric columns.
    
    Args:
        data: pandas DataFrame with dimension scores
        
    Returns:
        DataFrame with original data plus derived metric columns
    """
    # Calculate all derived metrics
    derived_metrics = calculate_all_derived_metrics(data)
    
    # Create a copy of the original data
    result = data.copy()
    
    # Add derived metrics as new columns
    for metric_name, metric_value in derived_metrics.items():
        if metric_value is not None:
            # For scalar metrics, broadcast to all rows
            result[metric_name] = metric_value
        else:
            # For failed calculations, use NaN
            result[metric_name] = np.nan
    
    return result
