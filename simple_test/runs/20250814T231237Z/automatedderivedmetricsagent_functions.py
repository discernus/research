"""
Automated Derived Metrics Functions
===================================

Generated by AutomatedDerivedMetricsAgent for experiment: democratic_discourse_cohesion_study
Description: Comparative analysis of social cohesion patterns across institutional and populist democratic discourse styles
Generated: 2025-08-14T23:12:12.964082+00:00

This module contains automatically generated calculation functions for derived metrics
as specified in the framework's natural language descriptions.
"""

import pandas as pd
import numpy as np
from typing import Optional, Dict, Any


def calculate_identity_tension(data, **kwargs):
    """
    Calculate Identity Tension as conflict between tribal dominance and individual dignity.
    
    Formula: abs(mean(tribal_dominance) - mean(individual_dignity))
    
    Args:
        data: pandas DataFrame with dimension scores. Expected columns: 'tribal_dominance', 'individual_dignity'.
        **kwargs: Additional parameters (not used in this function).
        
    Returns:
        float: Identity tension score (0.0-1.0) or None if insufficient data.
    """
    import pandas as pd
    try:
        required_cols = ['tribal_dominance', 'individual_dignity']
        
        if not all(col in data.columns for col in required_cols):
            return None
            
        tribal_dominance_score = data['tribal_dominance'].mean()
        individual_dignity_score = data['individual_dignity'].mean()
        
        if pd.isna(tribal_dominance_score) or pd.isna(individual_dignity_score):
            return None
            
        # The conflict is the absolute difference, scaled to 0-1 if needed, but dimensions are already 0-1.
        # The maximum difference is 1 (1-0 or 0-1).
        return abs(tribal_dominance_score - individual_dignity_score)
        
    except Exception as e:
        # Log the error for debugging in a real framework
        # print(f"Error calculating identity tension: {e}")
        return None

def calculate_emotional_balance(data, **kwargs):
    """
    Calculate Emotional Balance as hope scores minus fear scores.
    
    Formula: mean(hope) - mean(fear)
    
    Args:
        data: pandas DataFrame with dimension scores. Expected columns: 'hope', 'fear'.
        **kwargs: Additional parameters (not used in this function).
        
    Returns:
        float: Emotional balance score (-1.0 to 1.0) or None if insufficient data.
    """
    import pandas as pd
    try:
        required_cols = ['hope', 'fear']
        
        if not all(col in data.columns for col in required_cols):
            return None
            
        hope_score = data['hope'].mean()
        fear_score = data['fear'].mean()
        
        if pd.isna(hope_score) or pd.isna(fear_score):
            return None
            
        return hope_score - fear_score
        
    except Exception as e:
        # print(f"Error calculating emotional balance: {e}")
        return None

def calculate_success_climate(data, **kwargs):
    """
    Calculate Success Climate as compersion scores minus envy scores.
    
    Formula: mean(compersion) - mean(envy)
    
    Args:
        data: pandas DataFrame with dimension scores. Expected columns: 'compersion', 'envy'.
        **kwargs: Additional parameters (not used in this function).
        
    Returns:
        float: Success climate score (-1.0 to 1.0) or None if insufficient data.
    """
    import pandas as pd
    try:
        required_cols = ['compersion', 'envy']
        
        if not all(col in data.columns for col in required_cols):
            return None
            
        compersion_score = data['compersion'].mean()
        envy_score = data['envy'].mean()
        
        if pd.isna(compersion_score) or pd.isna(envy_score):
            return None
            
        return compersion_score - envy_score
        
    except Exception as e:
        # print(f"Error calculating success climate: {e}")
        return None

def calculate_relational_climate(data, **kwargs):
    """
    Calculate Relational Climate as amity scores minus enmity scores.
    
    Formula: mean(amity) - mean(enmity)
    
    Args:
        data: pandas DataFrame with dimension scores. Expected columns: 'amity', 'enmity'.
        **kwargs: Additional parameters (not used in this function).
        
    Returns:
        float: Relational climate score (-1.0 to 1.0) or None if insufficient data.
    """
    import pandas as pd
    try:
        required_cols = ['amity', 'enmity']
        
        if not all(col in data.columns for col in required_cols):
            return None
            
        amity_score = data['amity'].mean()
        enmity_score = data['enmity'].mean()
        
        if pd.isna(amity_score) or pd.isna(enmity_score):
            return None
            
        return amity_score - enmity_score
        
    except Exception as e:
        # print(f"Error calculating relational climate: {e}")
        return None

def calculate_goal_orientation(data, **kwargs):
    """
    Calculate Goal Orientation as cohesive goals minus fragmentative goals.
    
    Formula: mean(cohesive_goals) - mean(fragmentative_goals)
    
    Args:
        data: pandas DataFrame with dimension scores. Expected columns: 'cohesive_goals', 'fragmentative_goals'.
        **kwargs: Additional parameters (not used in this function).
        
    Returns:
        float: Goal orientation score (-1.0 to 1.0) or None if insufficient data.
    """
    import pandas as pd
    try:
        required_cols = ['cohesive_goals', 'fragmentative_goals']
        
        if not all(col in data.columns for col in required_cols):
            return None
            
        cohesive_goals_score = data['cohesive_goals'].mean()
        fragmentative_goals_score = data['fragmentative_goals'].mean()
        
        if pd.isna(cohesive_goals_score) or pd.isna(fragmentative_goals_score):
            return None
            
        return cohesive_goals_score - fragmentative_goals_score
        
    except Exception as e:
        # print(f"Error calculating goal orientation: {e}")
        return None

def calculate_overall_cohesion_index(data, **kwargs):
    """
    Calculate Overall Cohesion Index as the average of positive dimensions minus the average of negative dimensions.
    
    Positive Dimensions: Individual Dignity, Hope, Compersion, Amity, Cohesive Goals
    Negative Dimensions: Tribal Dominance, Fear, Envy, Enmity, Fragmentative Goals
    
    Formula: mean(mean(positive_dims)) - mean(mean(negative_dims))
    
    Args:
        data: pandas DataFrame with dimension scores.
        **kwargs: Additional parameters (not used in this function).
        
    Returns:
        float: Overall cohesion index (-1.0 to 1.0) or None if insufficient data.
    """
    import pandas as pd
    try:
        positive_dims = ['individual_dignity', 'hope', 'compersion', 'amity', 'cohesive_goals']
        negative_dims = ['tribal_dominance', 'fear', 'envy', 'enmity', 'fragmentative_goals']
        
        # Filter for available columns
        available_positive_dims = [d for d in positive_dims if d in data.columns]
        available_negative_dims = [d for d in negative_dims if d in data.columns]

        if not available_positive_dims and not available_negative_dims:
            return None # No relevant data at all

        avg_positive = None
        if available_positive_dims:
            # Calculate mean across rows for available positive dimensions, then mean of that series
            positive_scores = data[available_positive_dims].mean(axis=1).mean()
            if not pd.isna(positive_scores):
                avg_positive = positive_scores

        avg_negative = None
        if available_negative_dims:
            # Calculate mean across rows for available negative dimensions, then mean of that series
            negative_scores = data[available_negative_dims].mean(axis=1).mean()
            if not pd.isna(negative_scores):
                avg_negative = negative_scores
        
        if avg_positive is None and avg_negative is None:
            return None # Still no valid averages

        # Handle cases where one average is missing but the other is present
        if avg_positive is None:
            # If no positive dimensions, treat their average as 0 for the calculation,
            # but only if there are negative dimensions to subtract from.
            # This assumes a neutral baseline for missing positive dimensions.
            # Alternatively, one might return None if a core component is missing.
            # For this framework, we'll assume 0 if no data for that category.
            avg_positive = 0.0
        
        if avg_negative is None:
            # Similar logic for negative dimensions.
            avg_negative = 0.0

        return avg_positive - avg_negative
        
    except Exception as e:
        # print(f"Error calculating overall cohesion index: {e}")
        return None

def calculate_all_derived_metrics(data: pd.DataFrame) -> Dict[str, Optional[float]]:
    """
    Calculate all derived metrics for the given dataset.
    
    Args:
        data: pandas DataFrame with dimension scores
        
    Returns:
        Dictionary mapping metric names to calculated values
    """
    results = {}
    
    # Get all calculation functions from this module
    import inspect
    current_module = inspect.getmodule(inspect.currentframe())
    
    for name, obj in inspect.getmembers(current_module):
        if (inspect.isfunction(obj) and 
            name.startswith('calculate_') and 
            name != 'calculate_all_derived_metrics'):
            try:
                results[name.replace('calculate_', '')] = obj(data)
            except Exception as e:
                results[name.replace('calculate_', '')] = None
                
    return results
