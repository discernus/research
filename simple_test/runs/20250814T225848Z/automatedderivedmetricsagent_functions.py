"""
Automated Derived Metrics Functions
===================================

Generated by AutomatedDerivedMetricsAgent for experiment: democratic_discourse_cohesion_study
Description: Comparative analysis of social cohesion patterns across institutional and populist democratic discourse styles
Generated: 2025-08-14T22:58:48.885936+00:00

This module contains automatically generated calculation functions for derived metrics
as specified in the framework's natural language descriptions.
"""

import pandas as pd
import numpy as np
from typing import Optional, Dict, Any


def calculate_identity_tension(data, **kwargs):
    """
    Calculate Identity Tension as conflict between tribal dominance and individual dignity.
    
    Formula: abs(mean(tribal_dominance_score) - mean(individual_dignity_score))
    
    Args:
        data: pandas DataFrame with dimension scores. Expected columns: 'tribal_dominance_score', 'individual_dignity_score'.
        **kwargs: Additional parameters (not used in this function).
        
    Returns:
        float: Identity tension score (0.0-1.0) or None if insufficient data.
    """
    try:
        required_cols = ['tribal_dominance_score', 'individual_dignity_score']
        if not all(col in data.columns for col in required_cols):
            return None
            
        tribal_dominance = data['tribal_dominance_score'].mean()
        individual_dignity = data['individual_dignity_score'].mean()
        
        if pd.isna(tribal_dominance) or pd.isna(individual_dignity):
            return None
            
        # The range of individual dimensions is 0.0-1.0.
        # The difference can range from -1.0 to 1.0.
        # abs() makes it 0.0-1.0.
        return abs(tribal_dominance - individual_dignity)
        
    except Exception:
        return None

def calculate_emotional_balance(data, **kwargs):
    """
    Calculate Emotional Balance as hope scores minus fear scores.
    
    Formula: mean(hope_score) - mean(fear_score)
    
    Args:
        data: pandas DataFrame with dimension scores. Expected columns: 'hope_score', 'fear_score'.
        **kwargs: Additional parameters (not used in this function).
        
    Returns:
        float: Emotional balance score (-1.0 to 1.0) or None if insufficient data.
    """
    try:
        required_cols = ['hope_score', 'fear_score']
        if not all(col in data.columns for col in required_cols):
            return None
            
        hope_score = data['hope_score'].mean()
        fear_score = data['fear_score'].mean()
        
        if pd.isna(hope_score) or pd.isna(fear_score):
            return None
            
        # The range of individual dimensions is 0.0-1.0.
        # The difference can range from -1.0 to 1.0.
        return hope_score - fear_score
        
    except Exception:
        return None

def calculate_success_climate(data, **kwargs):
    """
    Calculate Success Climate as compersion scores minus envy scores.
    
    Formula: mean(compersion_score) - mean(envy_score)
    
    Args:
        data: pandas DataFrame with dimension scores. Expected columns: 'compersion_score', 'envy_score'.
        **kwargs: Additional parameters (not used in this function).
        
    Returns:
        float: Success climate score (-1.0 to 1.0) or None if insufficient data.
    """
    try:
        required_cols = ['compersion_score', 'envy_score']
        if not all(col in data.columns for col in required_cols):
            return None
            
        compersion_score = data['compersion_score'].mean()
        envy_score = data['envy_score'].mean()
        
        if pd.isna(compersion_score) or pd.isna(envy_score):
            return None
            
        # The range of individual dimensions is 0.0-1.0.
        # The difference can range from -1.0 to 1.0.
        return compersion_score - envy_score
        
    except Exception:
        return None

def calculate_relational_climate(data, **kwargs):
    """
    Calculate Relational Climate as amity scores minus enmity scores.
    
    Formula: mean(amity_score) - mean(enmity_score)
    
    Args:
        data: pandas DataFrame with dimension scores. Expected columns: 'amity_score', 'enmity_score'.
        **kwargs: Additional parameters (not used in this function).
        
    Returns:
        float: Relational climate score (-1.0 to 1.0) or None if insufficient data.
    """
    try:
        required_cols = ['amity_score', 'enmity_score']
        if not all(col in data.columns for col in required_cols):
            return None
            
        amity_score = data['amity_score'].mean()
        enmity_score = data['enmity_score'].mean()
        
        if pd.isna(amity_score) or pd.isna(enmity_score):
            return None
            
        # The range of individual dimensions is 0.0-1.0.
        # The difference can range from -1.0 to 1.0.
        return amity_score - enmity_score
        
    except Exception:
        return None

def calculate_goal_orientation(data, **kwargs):
    """
    Calculate Goal Orientation as cohesive goals minus fragmentative goals.
    
    Formula: mean(cohesive_goals_score) - mean(fragmentative_goals_score)
    
    Args:
        data: pandas DataFrame with dimension scores. Expected columns: 'cohesive_goals_score', 'fragmentative_goals_score'.
        **kwargs: Additional parameters (not used in this function).
        
    Returns:
        float: Goal orientation score (-1.0 to 1.0) or None if insufficient data.
    """
    try:
        required_cols = ['cohesive_goals_score', 'fragmentative_goals_score']
        if not all(col in data.columns for col in required_cols):
            return None
            
        cohesive_goals_score = data['cohesive_goals_score'].mean()
        fragmentative_goals_score = data['fragmentative_goals_score'].mean()
        
        if pd.isna(cohesive_goals_score) or pd.isna(fragmentative_goals_score):
            return None
            
        # The range of individual dimensions is 0.0-1.0.
        # The difference can range from -1.0 to 1.0.
        return cohesive_goals_score - fragmentative_goals_score
        
    except Exception:
        return None

def calculate_overall_cohesion_index(data, **kwargs):
    """
    Calculate Overall Cohesion Index as the average of positive dimensions minus the average of negative dimensions.
    
    Positive Dimensions: Individual Dignity, Hope, Compersion, Amity, Cohesive Goals
    Negative Dimensions: Tribal Dominance, Fear, Envy, Enmity, Fragmentative Goals
    
    Formula: Avg(Individual Dignity, Hope, Compersion, Amity, Cohesive Goals) - Avg(Tribal Dominance, Fear, Envy, Enmity, Fragmentative Goals)
    
    Args:
        data: pandas DataFrame with dimension scores. Expected columns:
              'individual_dignity_score', 'hope_score', 'compersion_score', 'amity_score', 'cohesive_goals_score',
              'tribal_dominance_score', 'fear_score', 'envy_score', 'enmity_score', 'fragmentative_goals_score'.
        **kwargs: Additional parameters (not used in this function).
        
    Returns:
        float: Overall cohesion index score (-1.0 to 1.0) or None if insufficient data.
    """
    try:
        positive_dims = [
            'individual_dignity_score', 'hope_score', 'compersion_score', 
            'amity_score', 'cohesive_goals_score'
        ]
        negative_dims = [
            'tribal_dominance_score', 'fear_score', 'envy_score', 
            'enmity_score', 'fragmentative_goals_score'
        ]

        # Filter for available columns
        available_positive_dims = [col for col in positive_dims if col in data.columns]
        available_negative_dims = [col for col in negative_dims if col in data.columns]

        if not available_positive_dims and not available_negative_dims:
            return None # No relevant data at all

        avg_positive = None
        if available_positive_dims:
            # Calculate mean of means for positive dimensions, handling NaNs
            positive_scores = data[available_positive_dims].mean(axis=0)
            if not positive_scores.empty and not positive_scores.isnull().all():
                avg_positive = positive_scores.mean()

        avg_negative = None
        if available_negative_dims:
            # Calculate mean of means for negative dimensions, handling NaNs
            negative_scores = data[available_negative_dims].mean(axis=0)
            if not negative_scores.empty and not negative_scores.isnull().all():
                avg_negative = negative_scores.mean()

        if pd.isna(avg_positive) and pd.isna(avg_negative):
            return None # Both averages are missing

        # If one average is missing, we cannot compute the difference meaningfully
        if pd.isna(avg_positive) or pd.isna(avg_negative):
            return None
            
        # The range of individual dimensions is 0.0-1.0.
        # The average of 5 dimensions will also be 0.0-1.0.
        # The difference can range from -1.0 to 1.0.
        return avg_positive - avg_negative
        
    except Exception:
        return None

def calculate_all_derived_metrics(data: pd.DataFrame) -> Dict[str, Optional[float]]:
    """
    Calculate all derived metrics for the given dataset.
    
    Args:
        data: pandas DataFrame with dimension scores
        
    Returns:
        Dictionary mapping metric names to calculated values
    """
    results = {}
    
    # Get all calculation functions from this module
    import inspect
    current_module = inspect.getmodule(inspect.currentframe())
    
    for name, obj in inspect.getmembers(current_module):
        if (inspect.isfunction(obj) and 
            name.startswith('calculate_') and 
            name != 'calculate_all_derived_metrics'):
            try:
                results[name.replace('calculate_', '')] = obj(data)
            except Exception as e:
                results[name.replace('calculate_', '')] = None
                
    return results
