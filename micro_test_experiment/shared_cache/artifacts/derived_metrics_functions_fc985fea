{
  "status": "success",
  "functions_generated": 6,
  "output_file": "automatedderivedmetricsagent_functions.py",
  "module_size": 11587,
  "function_code_content": "\"\"\"\nAutomated Derived Metrics Functions\n===================================\n\nGenerated by AutomatedDerivedMetricsAgent for experiment: Test Experiment\nDescription: Test experiment for derived metrics\nGenerated: 2025-09-01T17:39:13.398478+00:00\n\nThis module contains automatically generated calculation functions for derived metrics\nas specified in the framework's natural language descriptions.\n\"\"\"\n\nimport pandas as pd\nimport numpy as np\nfrom typing import Optional, Dict, Any\n\n\ndef calculate_identity_tension(data, **kwargs):\n    \"\"\"\n    Calculate identity_tension: Conflict between tribal dominance and individual dignity dimensions\n    \n    Formula: Since no relevant dimension columns are available in the data structure,\n    this function returns None as there is insufficient data to calculate identity tension.\n    \n    Args:\n        data: pandas DataFrame with dimension scores\n        **kwargs: Additional parameters\n        \n    Returns:\n        float: Calculated result or None if insufficient data\n    \"\"\"\n    import pandas as pd\n    import numpy as np\n    \n    try:\n        # Check if data is valid\n        if data is None or data.empty:\n            return None\n            \n        # The available columns (analysis_result, raw_analysis_response, scores_hash, \n        # evidence_hash, document_id, filename) do not contain the tribal dominance \n        # or individual dignity dimensions needed to calculate identity tension\n        \n        # Since there are no relevant dimension scores available in the data structure,\n        # we cannot calculate identity tension and must return None\n        return None\n        \n    except Exception:\n        return None\n\ndef calculate_emotional_balance(data, **kwargs):\n    \"\"\"\n    Calculate emotional_balance: Difference between hope and fear scores\n    \n    Formula: emotional_balance = hope_score - fear_score\n    \n    Args:\n        data: pandas DataFrame with dimension scores\n        **kwargs: Additional parameters\n        \n    Returns:\n        float: Calculated result or None if insufficient data\n    \"\"\"\n    import pandas as pd\n    import numpy as np\n    \n    try:\n        # Check if data is a Series (single row) or DataFrame\n        if isinstance(data, pd.Series):\n            row = data\n        elif isinstance(data, pd.DataFrame) and len(data) > 0:\n            row = data.iloc[0]\n        else:\n            return None\n            \n        # Look for hope and fear scores in the available columns\n        # Since the actual data structure doesn't contain these specific columns,\n        # we need to check what's available and handle gracefully\n        hope_score = None\n        fear_score = None\n        \n        # Check for potential hope/fear columns or use available numeric data\n        available_columns = row.index.tolist()\n        \n        for col in available_columns:\n            if pd.notna(row[col]) and isinstance(row[col], (int, float)):\n                if 'hope' in str(col).lower():\n                    hope_score = float(row[col])\n                elif 'fear' in str(col).lower():\n                    fear_score = float(row[col])\n        \n        # If no specific hope/fear columns found, return None\n        if hope_score is None or fear_score is None:\n            return None\n            \n        # Calculate emotional balance as difference\n        result = hope_score - fear_score\n        \n        return float(result) if pd.notna(result) else None\n        \n    except Exception:\n        return None\n\ndef calculate_success_climate(data, **kwargs):\n    \"\"\"\n    Calculate success_climate: Difference between compersion and envy scores\n    \n    Formula: compersion - envy\n    \n    Args:\n        data: pandas DataFrame with dimension scores\n        **kwargs: Additional parameters\n        \n    Returns:\n        float: Calculated result or None if insufficient data\n    \"\"\"\n    import pandas as pd\n    import numpy as np\n    \n    try:\n        # Convert to Series if DataFrame with single row\n        if isinstance(data, pd.DataFrame):\n            if len(data) == 1:\n                data = data.iloc[0]\n            else:\n                return None\n        \n        # Check if compersion and envy columns exist and have valid values\n        if 'compersion' not in data or 'envy' not in data:\n            return None\n            \n        compersion = data.get('compersion')\n        envy = data.get('envy')\n        \n        # Handle missing or invalid values\n        if pd.isna(compersion) or pd.isna(envy):\n            return None\n            \n        # Convert to float and calculate difference\n        compersion_val = float(compersion)\n        envy_val = float(envy)\n        \n        return compersion_val - envy_val\n        \n    except Exception:\n        return None\n\ndef calculate_relational_climate(data, **kwargs):\n    \"\"\"\n    Calculate relational_climate: Difference between amity and enmity scores\n    \n    Formula: amity - enmity\n    \n    Args:\n        data: pandas DataFrame with dimension scores\n        **kwargs: Additional parameters (may contain amity_score, enmity_score)\n        \n    Returns:\n        float: Calculated result or None if insufficient data\n    \"\"\"\n    import pandas as pd\n    import numpy as np\n    \n    try:\n        # Try to get amity and enmity scores from kwargs first\n        amity_score = kwargs.get('amity_score')\n        enmity_score = kwargs.get('enmity_score')\n        \n        # If not in kwargs, try to find in data columns (though none match the expected pattern)\n        if amity_score is None or enmity_score is None:\n            # Check if data has amity/enmity columns (fallback)\n            if hasattr(data, 'get'):\n                amity_score = data.get('amity', data.get('amity_score'))\n                enmity_score = data.get('enmity', data.get('enmity_score'))\n        \n        # Validate scores\n        if amity_score is None or enmity_score is None:\n            return None\n            \n        if pd.isna(amity_score) or pd.isna(enmity_score):\n            return None\n            \n        # Calculate relational climate\n        result = float(amity_score) - float(enmity_score)\n        \n        return result\n        \n    except Exception:\n        return None\n\ndef calculate_goal_orientation(data, **kwargs):\n    \"\"\"\n    Calculate goal_orientation: Difference between cohesive goals and fragmentative goals\n    \n    Formula: goal_orientation = cohesive_goals - fragmentative_goals\n    \n    Args:\n        data: pandas DataFrame with dimension scores\n        **kwargs: Additional parameters (cohesive_goals, fragmentative_goals)\n        \n    Returns:\n        float: Calculated result or None if insufficient data\n    \"\"\"\n    import pandas as pd\n    import numpy as np\n    \n    try:\n        # Extract cohesive and fragmentative goals from kwargs\n        cohesive_goals = kwargs.get('cohesive_goals')\n        fragmentative_goals = kwargs.get('fragmentative_goals')\n        \n        # If not provided in kwargs, return None as we cannot calculate from available columns\n        if cohesive_goals is None or fragmentative_goals is None:\n            return None\n            \n        # Validate inputs are numeric\n        if not isinstance(cohesive_goals, (int, float)) or not isinstance(fragmentative_goals, (int, float)):\n            return None\n            \n        # Check for NaN values\n        if pd.isna(cohesive_goals) or pd.isna(fragmentative_goals):\n            return None\n            \n        # Calculate goal orientation as difference\n        result = float(cohesive_goals - fragmentative_goals)\n        \n        return result\n        \n    except Exception:\n        return None\n\ndef calculate_overall_cohesion_index(data, **kwargs):\n    \"\"\"\n    Calculate overall_cohesion_index: Comprehensive measure combining all dimensions\n    \n    Formula: Returns None due to insufficient numeric data in available columns\n    \n    Args:\n        data: pandas DataFrame with dimension scores\n        **kwargs: Additional parameters\n        \n    Returns:\n        float: Calculated result or None if insufficient data\n    \"\"\"\n    import pandas as pd\n    import numpy as np\n    \n    try:\n        # Check if data is a Series (single row) or DataFrame\n        if isinstance(data, pd.Series):\n            row = data\n        else:\n            if len(data) == 0:\n                return None\n            row = data.iloc[0]\n        \n        # Available columns are mostly NaN/non-numeric:\n        # analysis_result, raw_analysis_response, scores_hash, evidence_hash, document_id, filename\n        \n        # Extract available numeric values\n        numeric_values = []\n        for col in ['analysis_result', 'raw_analysis_response', 'scores_hash', \n                   'evidence_hash', 'document_id', 'filename']:\n            if col in row and pd.notna(row[col]):\n                try:\n                    val = float(row[col])\n                    if not np.isinf(val):\n                        numeric_values.append(val)\n                except (ValueError, TypeError):\n                    continue\n        \n        # If we have some numeric values, calculate a simple cohesion index\n        if len(numeric_values) >= 2:\n            # Use coefficient of variation as inverse cohesion measure\n            mean_val = np.mean(numeric_values)\n            if mean_val != 0:\n                cv = np.std(numeric_values) / abs(mean_val)\n                # Convert to cohesion index (lower variation = higher cohesion)\n                cohesion_index = max(0, 1.0 - min(cv, 1.0))\n                return round(cohesion_index, 4)\n        \n        # Insufficient data for meaningful calculation\n        return None\n        \n    except Exception:\n        return None\n\ndef calculate_all_derived_metrics(data: pd.DataFrame) -> Dict[str, Optional[float]]:\n    \"\"\"\n    Calculate all derived metrics for the given dataset.\n    \n    Args:\n        data: pandas DataFrame with dimension scores\n        \n    Returns:\n        Dictionary mapping metric names to calculated values\n    \"\"\"\n    results = {}\n    \n    # Get all calculation functions from this module\n    import inspect\n    current_module = inspect.getmodule(inspect.currentframe())\n    \n    for name, obj in inspect.getmembers(current_module):\n        if (inspect.isfunction(obj) and \n            name.startswith('calculate_') and \n            name not in ['calculate_all_derived_metrics', 'calculate_derived_metrics']):\n            try:\n                results[name.replace('calculate_', '')] = obj(data)\n            except Exception as e:\n                results[name.replace('calculate_', '')] = None\n                \n    return results\n\n\ndef calculate_derived_metrics(data: pd.DataFrame) -> pd.DataFrame:\n    \"\"\"\n    Template-compatible wrapper function for derived metrics calculation.\n    \n    This function is called by the universal notebook template and returns\n    the original data with additional derived metric columns.\n    \n    Args:\n        data: pandas DataFrame with dimension scores\n        \n    Returns:\n        DataFrame with original data plus derived metric columns\n    \"\"\"\n    # Calculate all derived metrics\n    derived_metrics = calculate_all_derived_metrics(data)\n    \n    # Create a copy of the original data\n    result = data.copy()\n    \n    # Add derived metrics as new columns\n    for metric_name, metric_value in derived_metrics.items():\n        if metric_value is not None:\n            # For scalar metrics, broadcast to all rows\n            result[metric_name] = metric_value\n        else:\n            # For failed calculations, use NaN\n            result[metric_name] = np.nan\n    \n    return result\n",
  "cached_with_code": true
}