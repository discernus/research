{
  "status": "success",
  "functions_generated": 5,
  "output_file": "automatedderivedmetricsagent_functions.py",
  "module_size": 5899,
  "function_code_content": "import pandas as pd\nimport numpy as np\nimport json\nfrom typing import Optional, Dict, Any, List\n\ndef _extract_scores(row: pd.Series) -> Optional[Dict[str, Any]]:\n    \"\"\"Extracts dimensional scores from a DataFrame row.\n\n    This helper function navigates the nested data structure, parses the\n    JSON string from 'raw_analysis_response', and returns the\n    'dimensional_scores' dictionary.\n\n    It handles multiple possible JSON container formats, including proprietary\n    delimiters and markdown code fences.\n\n    Args:\n        row: A pandas Series representing a single row of the DataFrame.\n\n    Returns:\n        A dictionary containing the dimensional scores, or None if any part\n        of the extraction process fails.\n    \"\"\"\n    try:\n        raw_response = row['analysis_result']['result_content']['raw_analysis_response']\n\n        start_marker = '<<<DISCERNUS_ANALYSIS_JSON_v6>>>'\n        end_marker = '<<<END_DISCERNUS_ANALYSIS_JSON_v6>>>'\n        json_content = None\n\n        if start_marker in raw_response and end_marker in raw_response:\n            start_idx = raw_response.find(start_marker) + len(start_marker)\n            end_idx = raw_response.find(end_marker)\n            json_content = raw_response[start_idx:end_idx].strip()\n        elif raw_response.strip().startswith(\"```json\"):\n            json_content = raw_response.strip()[7:-3].strip()\n        elif raw_response.strip().startswith(\"{\"):\n             json_content = raw_response.strip()\n\n        if not json_content:\n            return None\n\n        analysis_data = json.loads(json_content)\n\n        if 'document_analyses' in analysis_data and isinstance(analysis_data['document_analyses'], list) and analysis_data['document_analyses']:\n            document_analysis = analysis_data['document_analyses'][0]\n            return document_analysis.get('dimensional_scores')\n        return None\n    except (KeyError, IndexError, TypeError, json.JSONDecodeError):\n        return None\n\ndef calculate_net_sentiment(row: pd.Series, **kwargs) -> Optional[float]:\n    \"\"\"\n    Calculates the net sentiment balance (positive - negative).\n\n    Formula:\n    net_sentiment = dimensions.positive_sentiment.raw_score - dimensions.negative_sentiment.raw_score\n\n    Args:\n        row: A pandas Series representing a single row of the DataFrame.\n        **kwargs: Additional parameters (unused).\n\n    Returns:\n        The calculated net sentiment as a float, or None if scores are unavailable.\n    \"\"\"\n    scores = _extract_scores(row)\n    if scores and 'positive_sentiment' in scores and 'negative_sentiment' in scores:\n        try:\n            positive_score = scores['positive_sentiment']['raw_score']\n            negative_score = scores['negative_sentiment']['raw_score']\n            if isinstance(positive_score, (int, float)) and isinstance(negative_score, (int, float)):\n                return float(positive_score - negative_score)\n        except (KeyError, TypeError):\n            return None\n    return None\n\ndef calculate_sentiment_magnitude(row: pd.Series, **kwargs) -> Optional[float]:\n    \"\"\"\n    Calculates the average emotional intensity (positive + negative) / 2.\n\n    Formula:\n    sentiment_magnitude = (dimensions.positive_sentiment.raw_score + dimensions.negative_sentiment.raw_score) / 2\n\n    Args:\n        row: A pandas Series representing a single row of the DataFrame.\n        **kwargs: Additional parameters (unused).\n\n    Returns:\n        The calculated sentiment magnitude as a float, or None if scores are unavailable.\n    \"\"\"\n    scores = _extract_scores(row)\n    if scores and 'positive_sentiment' in scores and 'negative_sentiment' in scores:\n        try:\n            positive_score = scores['positive_sentiment']['raw_score']\n            negative_score = scores['negative_sentiment']['raw_score']\n            if isinstance(positive_score, (int, float)) and isinstance(negative_score, (int, float)):\n                return float((positive_score + negative_score) / 2.0)\n        except (KeyError, TypeError):\n            return None\n    return None\n\ndef calculate_all_derived_metrics(row: pd.Series, **kwargs) -> Dict[str, Optional[float]]:\n    \"\"\"\n    Calculates all derived metrics for a single data row.\n\n    This function calls each individual derived metric calculation function\n    and returns the results in a dictionary. It does not use reflection\n    and calls each function directly by name.\n\n    Args:\n        row: A pandas Series representing a single row of the DataFrame.\n        **kwargs: Additional parameters to pass to calculation functions.\n\n    Returns:\n        A dictionary where keys are the metric names and values are the\n        calculated scores.\n    \"\"\"\n    results = {\n        \"net_sentiment\": calculate_net_sentiment(row, **kwargs),\n        \"sentiment_magnitude\": calculate_sentiment_magnitude(row, **kwargs),\n    }\n    return results\n\ndef calculate_derived_metrics(data: pd.DataFrame, **kwargs) -> pd.DataFrame:\n    \"\"\"\n    Applies all derived metric calculations to the DataFrame.\n\n    This wrapper function iterates through each row of the input DataFrame,\n    applies all defined derived metric calculations, and appends the results\n    as new columns. It creates a copy of the input data to avoid side effects.\n\n    Args:\n        data: The input pandas DataFrame with analysis data.\n        **kwargs: Additional parameters to pass to calculation functions.\n\n    Returns:\n        A new pandas DataFrame with the original data plus new columns for\n        each calculated derived metric. Missing values are represented as NaN.\n    \"\"\"\n    if not isinstance(data, pd.DataFrame):\n        raise TypeError(\"Input 'data' must be a pandas DataFrame.\")\n\n    df = data.copy()\n\n    derived_metrics_series = df.apply(\n        lambda row: pd.Series(calculate_all_derived_metrics(row, **kwargs)),\n        axis=1\n    )\n\n    result_df = df.join(derived_metrics_series)\n\n    return result_df\n",
  "cached_with_code": true,
  "cache_metadata": {
    "cache_key": "derived_metrics_a12843a9dda5",
    "cached_at": "2025-01-15T14:30:00Z",
    "agent_name": "DerivedMetricsPhase"
  }
}