{
  "status": "success",
  "functions_generated": 8,
  "output_file": "automatedderivedmetricsagent_functions.py",
  "module_size": 8127,
  "function_code_content": "[\n  {\n    \"filename\": \"sentiment_binary_v1_calculations.py\",\n    \"content\": \"import pandas as pd\\nimport numpy as np\\nimport json\\nfrom typing import Optional, Dict, Any\\n\\ndef _get_scores_from_row(row: pd.Series) -> Optional[Dict[str, Any]]:\\n    \\\"\\\"\\\"\\n    Parses the 'raw_analysis_response' column of a DataFrame row to extract dimensional scores.\\n\\n    This helper function is designed to be robust against various data inconsistencies,\\n    including missing columns, non-string data, different JSON delimiters, malformed JSON,\\n    and variations in the nested data structure.\\n\\n    Args:\\n        row: A pandas Series representing a row of a DataFrame.\\n\\n    Returns:\\n        A dictionary containing the dimensional scores if found, otherwise None.\\n    \\\"\\\"\\\"\\n    if 'raw_analysis_response' not in row:\\n        return None\\n\\n    raw_response = row['raw_analysis_response']\\n    if not isinstance(raw_response, str):\\n        return None\\n\\n    json_content = None\\n    start_marker = '<<<DISCERNUS_ANALYSIS_JSON_v6>>>'\\n    end_marker = '<<<END_DISCERNUS_ANALYSIS_JSON_v6>>>'\\n\\n    # Primary parsing method based on explicit instructions\\n    if start_marker in raw_response and end_marker in raw_response:\\n        start_idx = raw_response.find(start_marker)\\n        end_idx = raw_response.find(end_marker)\\n        json_content = raw_response[start_idx + len(start_marker):end_idx].strip()\\n    # Fallback for markdown code fences\\n    elif raw_response.strip().startswith(\\\"```json\\\"):\\n        json_part = raw_response.strip()\\n        json_content = json_part[len(\\\"```json\\\"):].strip().rstrip('`')\\n    # Fallback for raw JSON strings\\n    elif raw_response.strip().startswith(\\\"{\\\"):\\n        json_content = raw_response.strip()\\n\\n    if not json_content:\\n        return None\\n\\n    try:\\n        analysis = json.loads(json_content)\\n        # Navigate the structure based on the sample data\\n        if 'document_analyses' in analysis and isinstance(analysis['document_analyses'], list) and len(analysis['document_analyses']) > 0:\\n            # The framework is designed for single document analysis per call\\n            doc_analysis = analysis['document_analyses'][0]\\n            if 'dimensional_scores' in doc_analysis:\\n                return doc_analysis['dimensional_scores']\\n    except (json.JSONDecodeError, KeyError, IndexError, TypeError):\\n        return None\\n    \\n    return None\\n\\ndef calculate_net_sentiment(data: pd.DataFrame, **kwargs) -> Optional[float]:\\n    \\\"\\\"\\\"\\n    Calculates the average Net Sentiment across all documents in the DataFrame.\\n    Net Sentiment is the balance between positive and negative sentiment.\\n\\n    Formula: mean(dimensions.positive_sentiment.raw_score - dimensions.negative_sentiment.raw_score)\\n\\n    Args:\\n        data: pandas DataFrame with a 'raw_analysis_response' column.\\n        **kwargs: Additional parameters (unused).\\n\\n    Returns:\\n        A single float representing the average net sentiment, or None if it cannot be calculated.\\n    \\\"\\\"\\\"\\n    def _calculate(row):\\n        scores = _get_scores_from_row(row)\\n        if scores:\\n            try:\\n                pos_score = scores.get('positive_sentiment', {}).get('raw_score')\\n                neg_score = scores.get('negative_sentiment', {}).get('raw_score')\\n                if pos_score is not None and neg_score is not None:\\n                    return float(pos_score) - float(neg_score)\\n            except (AttributeError, TypeError, ValueError):\\n                return None\\n        return None\\n\\n    if 'raw_analysis_response' not in data.columns:\\n        return None\\n\\n    net_sentiments = data.apply(_calculate, axis=1).dropna()\\n\\n    if net_sentiments.empty:\\n        return None\\n    \\n    return float(net_sentiments.mean())\\n\\ndef calculate_sentiment_magnitude(data: pd.DataFrame, **kwargs) -> Optional[float]:\\n    \\\"\\\"\\\"\\n    Calculates the average Sentiment Magnitude across all documents in the DataFrame.\\n    Sentiment Magnitude is the combined intensity of emotional language.\\n\\n    Formula: mean((dimensions.positive_sentiment.raw_score + dimensions.negative_sentiment.raw_score) / 2)\\n\\n    Args:\\n        data: pandas DataFrame with a 'raw_analysis_response' column.\\n        **kwargs: Additional parameters (unused).\\n\\n    Returns:\\n        A single float representing the average sentiment magnitude, or None if it cannot be calculated.\\n    \\\"\\\"\\\"\\n    def _calculate(row):\\n        scores = _get_scores_from_row(row)\\n        if scores:\\n            try:\\n                pos_score = scores.get('positive_sentiment', {}).get('raw_score')\\n                neg_score = scores.get('negative_sentiment', {}).get('raw_score')\\n                if pos_score is not None and neg_score is not None:\\n                    return (float(pos_score) + float(neg_score)) / 2.0\\n            except (AttributeError, TypeError, ValueError):\\n                return None\\n        return None\\n\\n    if 'raw_analysis_response' not in data.columns:\\n        return None\\n\\n    magnitudes = data.apply(_calculate, axis=1).dropna()\\n\\n    if magnitudes.empty:\\n        return None\\n        \\n    return float(magnitudes.mean())\\n\\ndef calculate_all_derived_metrics(data: pd.DataFrame, **kwargs) -> Dict[str, Optional[float]]:\\n    \\\"\\\"\\\"\\n    Calculates all derived metrics for the given DataFrame, returning a dictionary of aggregate scores.\\n    This function calls each individual metric calculation function directly by name.\\n\\n    Args:\\n        data: pandas DataFrame with analysis data.\\n        **kwargs: Additional parameters to be passed to calculation functions.\\n\\n    Returns:\\n        A dictionary where keys are metric names and values are the calculated aggregate scores.\\n    \\\"\\\"\\\"\\n    metrics = {\\n        \\\"net_sentiment\\\": calculate_net_sentiment(data, **kwargs),\\n        \\\"sentiment_magnitude\\\": calculate_sentiment_magnitude(data, **kwargs),\\n    }\\n    return metrics\\n\\ndef calculate_derived_metrics(data: pd.DataFrame, **kwargs) -> pd.DataFrame:\\n    \\\"\\\"\\\"\\n    Calculates all derived metrics for each row and adds them as new columns to the DataFrame.\\n\\n    This function processes each row, calculates the derived metrics based on its\\n    'raw_analysis_response' data, and appends the results as new columns named\\n    'net_sentiment' and 'sentiment_magnitude'.\\n\\n    Args:\\n        data: pandas DataFrame with a 'raw_analysis_response' column.\\n        **kwargs: Additional parameters (unused).\\n\\n    Returns:\\n        A new pandas DataFrame with the original data plus the new derived metric columns.\\n        Missing values in the new columns are filled with 0.0.\\n    \\\"\\\"\\\"\\n    df = data.copy()\\n    \\n    if 'raw_analysis_response' not in df.columns:\\n        df['net_sentiment'] = 0.0\\n        df['sentiment_magnitude'] = 0.0\\n        return df\\n\\n    def _calculate_metrics_for_row(row: pd.Series) -> pd.Series:\\n        \\\"\\\"\\\"Helper to calculate all metrics for a single row.\\\"\\\"\\\"\\n        scores = _get_scores_from_row(row)\\n        net_sentiment = None\\n        sentiment_magnitude = None\\n\\n        if scores:\\n            try:\\n                pos_score = scores.get('positive_sentiment', {}).get('raw_score')\\n                neg_score = scores.get('negative_sentiment', {}).get('raw_score')\\n\\n                if pos_score is not None and neg_score is not None:\\n                    pos_score_f = float(pos_score)\\n                    neg_score_f = float(neg_score)\\n                    net_sentiment = pos_score_f - neg_score_f\\n                    sentiment_magnitude = (pos_score_f + neg_score_f) / 2.0\\n            except (AttributeError, TypeError, ValueError):\\n                pass\\n\\n        return pd.Series({\\n            'net_sentiment': net_sentiment,\\n            'sentiment_magnitude': sentiment_magnitude\\n        })\\n\\n    derived_metrics_df = df.apply(_calculate_metrics_for_row, axis=1)\\n    \\n    df = df.join(derived_metrics_df)\\n\\n    df['net_sentiment'] = df['net_sentiment'].fillna(0.0)\\n    df['sentiment_magnitude'] = df['sentiment_magnitude'].fillna(0.0)\\n\\n    return df\\n\"\n  }\n]",
  "cached_with_code": true
}