{
  "status": "success",
  "functions_generated": 6,
  "output_file": "automatedderivedmetricsagent_functions.py",
  "module_size": 6273,
  "function_code_content": "import pandas as pd\nimport numpy as np\nimport json\nfrom typing import Optional, Dict, Any, List\n\ndef _get_scores_from_row(row: pd.Series) -> Optional[Dict[str, Any]]:\n    \"\"\"Extracts dimensional scores from a single DataFrame row.\"\"\"\n    raw_response = row.get('raw_analysis_response')\n    if not isinstance(raw_response, str):\n        return None\n\n    start_marker = '<<<DISCERNUS_ANALYSIS_JSON_v6>>>'\n    end_marker = '<<<END_DISCERNUS_ANALYSIS_JSON_v6>>>'\n    \n    start_idx = raw_response.find(start_marker)\n    if start_idx == -1:\n        return None\n        \n    end_idx = raw_response.find(end_marker, start_idx)\n    \n    if end_idx == -1:\n        json_content = raw_response[start_idx + len(start_marker):].strip()\n    else:\n        json_content = raw_response[start_idx + len(start_marker):end_idx].strip()\n\n    if not json_content:\n        return None\n\n    try:\n        analysis = json.loads(json_content)\n        if 'document_analyses' in analysis and isinstance(analysis['document_analyses'], list) and len(analysis['document_analyses']) > 0:\n            return analysis['document_analyses'][0].get('dimensional_scores')\n        return None\n    except (json.JSONDecodeError, KeyError, TypeError, IndexError):\n        return None\n\ndef calculate_net_sentiment(data: pd.DataFrame, **kwargs) -> Optional[float]:\n    \"\"\"\n    Calculates the average Net Sentiment across all documents in the DataFrame.\n    Formula for a single document: dimensions.positive_sentiment.raw_score - dimensions.negative_sentiment.raw_score\n\n    Args:\n        data (pd.DataFrame): DataFrame containing the analysis results.\n        **kwargs: Additional parameters (unused).\n\n    Returns:\n        Optional[float]: The average net sentiment, or None if no valid data is found.\n    \"\"\"\n    scores = []\n    for index, row in data.iterrows():\n        dimensional_scores = _get_scores_from_row(row)\n        if dimensional_scores:\n            try:\n                pos_score = dimensional_scores.get('positive_sentiment', {}).get('raw_score')\n                neg_score = dimensional_scores.get('negative_sentiment', {}).get('raw_score')\n                if pos_score is not None and neg_score is not None:\n                    scores.append(float(pos_score) - float(neg_score))\n            except (AttributeError, TypeError, ValueError):\n                continue\n    \n    if not scores:\n        return None\n    \n    return np.mean(scores)\n\ndef calculate_sentiment_magnitude(data: pd.DataFrame, **kwargs) -> Optional[float]:\n    \"\"\"\n    Calculates the average Sentiment Magnitude across all documents in the DataFrame.\n    Formula for a single document: (dimensions.positive_sentiment.raw_score + dimensions.negative_sentiment.raw_score) / 2\n\n    Args:\n        data (pd.DataFrame): DataFrame containing the analysis results.\n        **kwargs: Additional parameters (unused).\n\n    Returns:\n        Optional[float]: The average sentiment magnitude, or None if no valid data is found.\n    \"\"\"\n    scores = []\n    for index, row in data.iterrows():\n        dimensional_scores = _get_scores_from_row(row)\n        if dimensional_scores:\n            try:\n                pos_score = dimensional_scores.get('positive_sentiment', {}).get('raw_score')\n                neg_score = dimensional_scores.get('negative_sentiment', {}).get('raw_score')\n                if pos_score is not None and neg_score is not None:\n                    scores.append((float(pos_score) + float(neg_score)) / 2.0)\n            except (AttributeError, TypeError, ValueError):\n                continue\n    \n    if not scores:\n        return None\n        \n    return np.mean(scores)\n\ndef calculate_all_derived_metrics(data: pd.DataFrame, **kwargs) -> Dict[str, Optional[float]]:\n    \"\"\"\n    Calculates all derived metrics for the framework and returns them as a dictionary of aggregates.\n\n    Args:\n        data (pd.DataFrame): DataFrame containing the analysis results.\n        **kwargs: Additional parameters passed to individual calculation functions.\n\n    Returns:\n        Dict[str, Optional[float]]: A dictionary where keys are metric names\n                                     and values are the calculated scalar metrics.\n    \"\"\"\n    results = {\n        \"net_sentiment\": calculate_net_sentiment(data, **kwargs),\n        \"sentiment_magnitude\": calculate_sentiment_magnitude(data, **kwargs),\n    }\n    return results\n\ndef calculate_derived_metrics(data: pd.DataFrame, **kwargs) -> pd.DataFrame:\n    \"\"\"\n    Calculates all derived metrics for each row and adds them as new columns\n    to the DataFrame.\n\n    Args:\n        data (pd.DataFrame): The input DataFrame with a 'raw_analysis_response' column.\n        **kwargs: Additional parameters (unused).\n\n    Returns:\n        pd.DataFrame: A new DataFrame with the original data and additional columns\n                      for each calculated derived metric.\n    \"\"\"\n    if 'raw_analysis_response' not in data.columns:\n        df = data.copy()\n        df['net_sentiment'] = np.nan\n        df['sentiment_magnitude'] = np.nan\n        return df\n\n    df = data.copy()\n    \n    def process_row(row):\n        dimensional_scores = _get_scores_from_row(row)\n        if dimensional_scores:\n            try:\n                pos_score = dimensional_scores.get('positive_sentiment', {}).get('raw_score')\n                neg_score = dimensional_scores.get('negative_sentiment', {}).get('raw_score')\n                \n                if pos_score is not None and neg_score is not None:\n                    pos_score = float(pos_score)\n                    neg_score = float(neg_score)\n                    net_sentiment = pos_score - neg_score\n                    sentiment_magnitude = (pos_score + neg_score) / 2.0\n                    return pd.Series([net_sentiment, sentiment_magnitude])\n            except (AttributeError, TypeError, ValueError):\n                pass\n        return pd.Series([np.nan, np.nan])\n\n    derived_cols = ['net_sentiment', 'sentiment_magnitude']\n    # Use result_type='expand' to create new columns directly from the returned Series\n    new_cols_df = df.apply(process_row, axis=1, result_type='expand')\n    new_cols_df.columns = derived_cols\n\n    # Concatenate the new columns to the original DataFrame copy\n    df = pd.concat([df, new_cols_df], axis=1)\n\n    return df\n",
  "cached_with_code": true
}