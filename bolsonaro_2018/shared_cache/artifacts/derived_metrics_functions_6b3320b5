{
  "status": "success",
  "functions_generated": 6,
  "output_file": "automatedderivedmetricsagent_functions.py",
  "module_size": 15303,
  "function_code_content": "\"\"\"\nAutomated Derived Metrics Functions\n===================================\n\nGenerated by AutomatedDerivedMetricsAgent for experiment: Test Experiment\nDescription: Test experiment for derived metrics\nGenerated: 2025-09-01T20:00:32.530606+00:00\n\nThis module contains automatically generated calculation functions for derived metrics\nas specified in the framework's natural language descriptions.\n\"\"\"\n\nimport pandas as pd\nimport numpy as np\nfrom typing import Optional, Dict, Any\n\n\ndef calculate_identity_tension(data, **kwargs):\n    \"\"\"\n    Calculate identity_tension: Conflict between tribal dominance and individual dignity dimensions.\n\n    This calculation models the tension as the product of the 'tribal_dominance' and \n    'individual_dignity' scores. The rationale is that the conflict is most acute \n    when both dimensions are highly salient in the discourse.\n\n    Formula: identity_tension = tribal_dominance * individual_dignity\n\n    Args:\n        data (pd.Series or pd.DataFrame): A single row of data represented as a pandas Series \n                                         or a single-row DataFrame. It is expected to contain \n                                         columns named 'tribal_dominance' and 'individual_dignity'.\n        **kwargs: Additional keyword arguments (not used in this calculation).\n\n    Returns:\n        float: The calculated identity tension score. Returns None if the required \n               columns are missing, contain non-numeric data, or are NaN.\n    \"\"\"\n    import pandas as pd\n    import numpy as np\n\n    try:\n        # The PDAF framework defines this tension based on two core dimensions.\n        # We expect these conceptual dimensions to be present as columns in the data.\n        tribal_dominance = data['tribal_dominance']\n        individual_dignity = data['individual_dignity']\n\n        # The calculation is not possible if either score is missing.\n        if pd.isna(tribal_dominance) or pd.isna(individual_dignity):\n            return None\n\n        # The tension is calculated as the product of the two dimension scores.\n        # This ensures that the tension is highest when both values are high.\n        tension_score = float(tribal_dominance * individual_dignity)\n\n        return tension_score\n\n    except (KeyError, TypeError, ValueError):\n        # A KeyError occurs if the required columns ('tribal_dominance', 'individual_dignity')\n        # are not found in the input data.\n        # A TypeError or ValueError can occur if the data in those columns is not numeric.\n        # In any of these cases, the calculation cannot proceed.\n        return None\n    except Exception:\n        # A general catch-all for any other unexpected errors during execution.\n        return None\n\ndef calculate_emotional_balance(data, **kwargs):\n    \"\"\"\n    Calculate emotional_balance: Difference between hope and fear scores\n\n    Formula: hope - fear\n\n    Args:\n        data (pd.Series): A single row of data from the DataFrame.\n        **kwargs: Additional keyword arguments (unused).\n\n    Returns:\n        float: The calculated emotional balance score, or None if input data is missing or invalid.\n    \"\"\"\n    import pandas as pd\n    import numpy as np\n\n    try:\n        # The calculation requires 'hope' and 'fear' scores.\n        # These names are derived from the calculation description \"Difference between hope and fear scores\".\n        # The function attempts to access these scores from the input data.\n        # If the columns do not exist (as is the case in the sample data structure provided),\n        # a KeyError will be caught, and the function will gracefully return None.\n        hope_score = data['hope']\n        fear_score = data['fear']\n\n        # Ensure that the necessary scores are not null/NaN before calculation\n        if pd.isna(hope_score) or pd.isna(fear_score):\n            return None\n\n        # Calculate the difference and ensure the result is a standard float\n        result = float(hope_score) - float(fear_score)\n\n        return result\n\n    except (KeyError, TypeError, ValueError):\n        # KeyError: Catches cases where 'hope' or 'fear' columns are missing.\n        # TypeError/ValueError: Catches cases where scores are not numeric.\n        return None\n\ndef calculate_success_climate(data, **kwargs):\n    \"\"\"\n    Calculate success_climate: Difference between compersion and envy scores\n\n    Formula: success_climate = compersion - envy\n    \n    Args:\n        data (pd.Series): A single row of data represented as a pandas Series.\n        **kwargs: Additional keyword arguments (unused).\n        \n    Returns:\n        float: The calculated result, or None if the necessary 'compersion' or\n               'envy' columns are missing or contain non-numeric data.\n    \"\"\"\n    import pandas as pd\n    import numpy as np\n    \n    try:\n        # Define the column names required for this calculation\n        compersion_col = 'compersion'\n        envy_col = 'envy'\n        \n        # Extract scores. A KeyError will be raised if columns are missing,\n        # which is handled by the except block. This respects the requirement\n        # to not assume columns exist if they are not in the provided schema.\n        compersion_score = data[compersion_col]\n        envy_score = data[envy_col]\n        \n        # Check for non-numeric or missing values before calculation\n        if pd.isna(compersion_score) or pd.isna(envy_score):\n            return None\n            \n        # Perform the calculation and ensure the result is a float\n        result = float(compersion_score) - float(envy_score)\n        \n        # Ensure the final result is a finite number (not NaN or infinity)\n        if not np.isfinite(result):\n            return None\n            \n        return result\n        \n    except (KeyError, TypeError, ValueError):\n        # KeyError: Catches cases where 'compersion' or 'envy' columns do not exist.\n        # TypeError: Catches non-numeric data types that cannot be subtracted.\n        # ValueError: Catches issues with converting data to float.\n        return None\n\ndef calculate_relational_climate(data, **kwargs):\n    \"\"\"\n    Calculate relational_climate: Difference between amity and enmity scores.\n\n    Formula: relational_climate = amity - enmity\n\n    Args:\n        data (pd.Series): A single row of data expecting 'amity' and 'enmity' scores.\n        **kwargs: Additional keyword arguments (unused).\n\n    Returns:\n        float: The calculated score, or None if input data is missing or invalid.\n    \"\"\"\n    import pandas as pd\n    import numpy as np\n\n    try:\n        # Retrieve scores. This will raise a KeyError if a column is missing.\n        amity_score = data['amity']\n        enmity_score = data['enmity']\n\n        # Check for missing values (e.g., NaN, None) before calculation.\n        if pd.isna(amity_score) or pd.isna(enmity_score):\n            return None\n\n        # Convert to float to ensure numeric operation and handle non-numeric data.\n        # This will raise TypeError or ValueError if conversion is not possible.\n        result = float(amity_score) - float(enmity_score)\n        return result\n\n    except (KeyError, TypeError, ValueError):\n        # Gracefully return None if:\n        # - KeyError: 'amity' or 'enmity' columns are missing.\n        # - TypeError/ValueError: Score values are not convertible to a number.\n        return None\n\ndef calculate_goal_orientation(data, **kwargs):\n    \"\"\"\n    Calculate goal_orientation: Difference between cohesive goals and fragmentative goals\n\n    Formula: cohesive_goals - fragmentative_goals\n\n    Args:\n        data (pd.Series): A single row of data from the DataFrame. This function\n                          adheres to the provided schema and does not use columns\n                          from this object for this specific calculation.\n        **kwargs: Keyword arguments containing the necessary scores.\n                  Expected keys: 'cohesive_goals' (float), 'fragmentative_goals' (float).\n\n    Returns:\n        float: The calculated difference, or None if input data is\n               missing, invalid, or causes an error.\n    \"\"\"\n    import pandas as pd\n    import numpy as np\n\n    try:\n        # The conceptual dimensions 'cohesive_goals' and 'fragmentative_goals'\n        # are not in the core data schema and are expected to be passed via kwargs.\n        cohesive_goals = kwargs.get('cohesive_goals')\n        fragmentative_goals = kwargs.get('fragmentative_goals')\n\n        # Check for missing data. Return None if either component is not provided.\n        if cohesive_goals is None or fragmentative_goals is None:\n            return None\n\n        # Ensure values are numeric before calculation.\n        # This will raise a ValueError or TypeError for non-numeric types,\n        # which is caught by the except block below.\n        cohesive_score = float(cohesive_goals)\n        fragmentative_score = float(fragmentative_goals)\n\n        # The calculation is the simple difference between the two goal types.\n        result = cohesive_score - fragmentative_score\n\n        return result\n\n    except (ValueError, TypeError):\n        # This occurs if the values passed in kwargs are not valid numbers.\n        return None\n    except Exception:\n        # A catch-all for any other unexpected errors during execution.\n        return None\n\ndef calculate_overall_cohesion_index(data, **kwargs):\n    \"\"\"\n    Calculate overall_cohesion_index: Comprehensive measure combining all dimensions.\n\n    This function implements the Populist Discourse Analysis Framework (PDAF) v10.0.2\n    calculation for the Overall Cohesion Index. It computes a comprehensive measure\n    by calculating the salience-weighted average of all specified discourse dimensions.\n\n    The calculation maps the 4-level categorical scores (high, medium, low, absent)\n    to a numerical scale and applies weights to each dimension to determine their\n    relative importance in the final index.\n\n    Formula:\n        OCI = (\u03a3(S_i * W_i)) / \u03a3(W_i)\n        Where:\n        - S_i: Numeric score for dimension 'i' (high=3, medium=2, low=1, absent=0)\n        - W_i: Salience weight for dimension 'i'\n\n    If weights are not provided, a simple average is calculated (all W_i = 1).\n    The function is designed to operate on a single row/record of data.\n\n    Args:\n        data (pandas.DataFrame or pandas.Series):\n            A single row of data containing the dimension scores.\n        **kwargs:\n            Additional keyword arguments required for the calculation.\n            - dimension_columns (list[str]): REQUIRED. A list of the column names\n              that represent the dimensions to be included in the index.\n            - dimension_weights (dict[str, float] or list[float], optional):\n              The salience weights for each dimension.\n              If a dict, keys must be the dimension column names.\n              If a list, the order must correspond to `dimension_columns`.\n              Defaults to equal weights of 1 if not provided.\n\n    Returns:\n        float: The calculated Overall Cohesion Index. Returns None if the necessary\n               `dimension_columns` are not provided in kwargs, if columns are\n               missing from the data, or if no valid scores are found.\n    \"\"\"\n    import pandas as pd\n    import numpy as np\n\n    try:\n        dimension_columns = kwargs.get('dimension_columns')\n        if not dimension_columns or not isinstance(dimension_columns, list):\n            return None\n\n        # Ensure data is a single-row DataFrame for consistent access\n        if isinstance(data, pd.Series):\n            # Convert Series to a single-row DataFrame\n            row_data = data.to_frame().T\n        else:\n            # Assume the first row of the DataFrame is the target\n            row_data = data.head(1)\n\n        if row_data.empty:\n            return None\n\n        # Verify all required dimension columns exist in the data\n        if not all(col in row_data.columns for col in dimension_columns):\n            return None\n\n        score_map = {'high': 3, 'medium': 2, 'low': 1, 'absent': 0}\n        weights = kwargs.get('dimension_weights')\n\n        # Default to equal weights if none are provided\n        if weights is None:\n            weights = {col: 1.0 for col in dimension_columns}\n        elif isinstance(weights, list) and len(weights) == len(dimension_columns):\n            weights = dict(zip(dimension_columns, weights))\n        elif not isinstance(weights, dict) or not all(col in weights for col in dimension_columns):\n            # Invalid or incomplete weights provided\n            return None\n\n        total_weighted_score = 0.0\n        total_weight = 0.0\n\n        for col in dimension_columns:\n            # .iloc[0] is safe due to the single-row DataFrame structure\n            value = row_data[col].iloc[0]\n\n            if pd.notna(value) and value in score_map:\n                numeric_score = score_map[value]\n                weight = weights[col]\n                total_weighted_score += numeric_score * weight\n                total_weight += weight\n\n        if total_weight == 0:\n            # This occurs if all dimension scores were missing or invalid\n            return None\n\n        cohesion_index = total_weighted_score / total_weight\n        return float(cohesion_index)\n\n    except Exception:\n        # Gracefully handle any unexpected errors during processing\n        return None\n\ndef calculate_all_derived_metrics(data: pd.DataFrame) -> Dict[str, Optional[float]]:\n    \"\"\"\n    Calculate all derived metrics for the given dataset.\n    \n    Args:\n        data: pandas DataFrame with dimension scores\n        \n    Returns:\n        Dictionary mapping metric names to calculated values\n    \"\"\"\n    results = {}\n    \n    # Get all calculation functions from this module\n    import inspect\n    current_module = inspect.getmodule(inspect.currentframe())\n    \n    for name, obj in inspect.getmembers(current_module):\n        if (inspect.isfunction(obj) and \n            name.startswith('calculate_') and \n            name not in ['calculate_all_derived_metrics', 'calculate_derived_metrics']):\n            try:\n                results[name.replace('calculate_', '')] = obj(data)\n            except Exception as e:\n                results[name.replace('calculate_', '')] = None\n                \n    return results\n\n\ndef calculate_derived_metrics(data: pd.DataFrame) -> pd.DataFrame:\n    \"\"\"\n    Template-compatible wrapper function for derived metrics calculation.\n    \n    This function is called by the universal notebook template and returns\n    the original data with additional derived metric columns.\n    \n    Args:\n        data: pandas DataFrame with dimension scores\n        \n    Returns:\n        DataFrame with original data plus derived metric columns\n    \"\"\"\n    # Calculate all derived metrics\n    derived_metrics = calculate_all_derived_metrics(data)\n    \n    # Create a copy of the original data\n    result = data.copy()\n    \n    # Add derived metrics as new columns\n    for metric_name, metric_value in derived_metrics.items():\n        if metric_value is not None:\n            # For scalar metrics, broadcast to all rows\n            result[metric_name] = metric_value\n        else:\n            # For failed calculations, use NaN\n            result[metric_name] = np.nan\n    \n    return result\n",
  "cached_with_code": true
}