#!/usr/bin/env python3
"""
Statistical analysis functions - generated by LogicOnlyAgent
These functions contain ONLY calculation logic, no data handling.
"""

import pandas as pd
import numpy as np
from scipy import stats
import warnings
warnings.filterwarnings('ignore')

def calculate_descriptive_statistics(df):
    """Calculate mean, median, std dev for all numeric columns."""
    try:
        numeric_cols = df.select_dtypes(include=[np.number]).columns
        results = {}
        
        for col in numeric_cols:
            results[col] = {
                'mean': float(df[col].mean()),
                'median': float(df[col].median()),
                'std': float(df[col].std()),
                'min': float(df[col].min()),
                'max': float(df[col].max()),
                'count': int(df[col].count())
            }
        
        return {
            'type': 'descriptive_statistics',
            'success': True,
            'statistics': results,
            'columns_analyzed': list(numeric_cols)
        }
    
    except Exception as e:
        return {
            'type': 'descriptive_statistics',
            'success': False,
            'error': str(e)
        }

def calculate_correlation_matrix(df):
    """Calculate Pearson correlations between derived metrics."""
    try:
        # Focus on derived metrics (tension scores and indices)
        metric_cols = [col for col in df.columns if any(term in col.lower() 
                      for term in ['tension', 'index', 'cohesive', 'fragmentative'])]
        
        if len(metric_cols) < 2:
            return {
                'type': 'correlation_analysis',
                'success': False,
                'error': 'Insufficient metric columns for correlation analysis'
            }
        
        corr_matrix = df[metric_cols].corr()
        
        # Calculate p-values
        p_values = {}
        for i, col1 in enumerate(metric_cols):
            p_values[col1] = {}
            for j, col2 in enumerate(metric_cols):
                if i != j:
                    corr_coef, p_val = stats.pearsonr(df[col1].dropna(), df[col2].dropna())
                    p_values[col1][col2] = float(p_val)
                else:
                    p_values[col1][col2] = 0.0
        
        return {
            'type': 'correlation_analysis',
            'success': True,
            'correlation_matrix': corr_matrix.to_dict(),
            'p_values': p_values,
            'significant_correlations': [
                {'col1': col1, 'col2': col2, 'correlation': corr_matrix.loc[col1, col2], 'p_value': p_values[col1][col2]}
                for col1 in metric_cols for col2 in metric_cols 
                if col1 != col2 and p_values[col1][col2] < 0.05
            ]
        }
    
    except Exception as e:
        return {
            'type': 'correlation_analysis',
            'success': False,
            'error': str(e)
        }

def perform_cohesion_analysis(df):
    """Compare cohesive vs fragmentative patterns with t-tests."""
    try:
        # Look for cohesive and fragmentative indices
        cohesive_cols = [col for col in df.columns if 'cohesive' in col.lower()]
        fragmentative_cols = [col for col in df.columns if 'fragmentative' in col.lower()]
        
        if not cohesive_cols or not fragmentative_cols:
            return {
                'type': 'cohesion_analysis',
                'success': False,
                'error': 'Missing cohesive or fragmentative index columns'
            }
        
        results = {}
        
        # T-test between cohesive and fragmentative indices
        for coh_col in cohesive_cols:
            for frag_col in fragmentative_cols:
                cohesive_values = df[coh_col].dropna()
                fragmentative_values = df[frag_col].dropna()
                
                t_stat, p_value = stats.ttest_rel(cohesive_values, fragmentative_values)
                
                results[f'{coh_col}_vs_{frag_col}'] = {
                    'cohesive_mean': float(cohesive_values.mean()),
                    'fragmentative_mean': float(fragmentative_values.mean()),
                    'difference': float(cohesive_values.mean() - fragmentative_values.mean()),
                    't_statistic': float(t_stat),
                    'p_value': float(p_value),
                    'significant': p_value < 0.05,
                    'effect_size': float(t_stat / np.sqrt(len(cohesive_values)))
                }
        
        return {
            'type': 'cohesion_analysis',
            'success': True,
            'comparisons': results
        }
    
    except Exception as e:
        return {
            'type': 'cohesion_analysis',
            'success': False,
            'error': str(e)
        }

def analyze_tension_patterns(df):
    """Statistical analysis of tension score patterns."""
    try:
        # Find tension score columns
        tension_cols = [col for col in df.columns if 'tension' in col.lower()]
        
        if len(tension_cols) < 2:
            return {
                'type': 'tension_analysis',
                'success': False,
                'error': 'Insufficient tension columns for pattern analysis'
            }
        
        results = {}
        
        # Overall tension statistics
        tension_data = df[tension_cols]
        results['overall_statistics'] = {
            'mean_tension': float(tension_data.mean().mean()),
            'max_tension': float(tension_data.max().max()),
            'min_tension': float(tension_data.min().min()),
            'tension_variance': float(tension_data.var().mean())
        }
        
        # Identify dominant tension type
        tension_means = tension_data.mean().sort_values(ascending=False)
        results['dominant_tensions'] = {
            'highest': {
                'type': tension_means.index[0],
                'score': float(tension_means.iloc[0])
            },
            'lowest': {
                'type': tension_means.index[-1],
                'score': float(tension_means.iloc[-1])
            }
        }
        
        # ANOVA test across tension types
        tension_values = [df[col].dropna().values for col in tension_cols]
        f_stat, p_value = stats.f_oneway(*tension_values)
        
        results['anova_test'] = {
            'f_statistic': float(f_stat),
            'p_value': float(p_value),
            'significant_difference': p_value < 0.05
        }
        
        return {
            'type': 'tension_analysis',
            'success': True,
            'analysis': results
        }
    
    except Exception as e:
        return {
            'type': 'tension_analysis',
            'success': False,
            'error': str(e)
        }
