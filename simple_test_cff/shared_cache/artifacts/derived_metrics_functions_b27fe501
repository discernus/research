{
  "status": "success",
  "functions_generated": 6,
  "output_file": "automatedderivedmetricsagent_functions.py",
  "module_size": 12686,
  "function_code_content": "\"\"\"\nAutomated Derived Metrics Functions\n===================================\n\nGenerated by AutomatedDerivedMetricsAgent for experiment: Test Experiment\nDescription: Test experiment for derived metrics\nGenerated: 2025-08-27T04:57:51.359689+00:00\n\nThis module contains automatically generated calculation functions for derived metrics\nas specified in the framework's natural language descriptions.\n\"\"\"\n\nimport pandas as pd\nimport numpy as np\nfrom typing import Optional, Dict, Any\n\n\ndef calculate_identity_tension(data, **kwargs):\n    \"\"\"\n    Calculate identity_tension: Conflict between tribal dominance and individual dignity dimensions.\n\n    This function measures the tension between two opposing dimensions: the appeal to group/tribal identity and the appeal to individual dignity. High tension indicates that both concepts are being invoked simultaneously and strongly, representing a complex or conflicted rhetorical position. The calculation is based on the principle that tension is highest when two opposing forces are balanced and strong.\n\n    Formula: (tribal_dominance + individual_dignity) - abs(tribal_dominance - individual_dignity)\n    This is mathematically equivalent to 2 * min(tribal_dominance, individual_dignity).\n    \n    Args:\n        data (pd.Series): A single row of data as a pandas Series,\n                         containing the dimension scores.\n        **kwargs: Additional parameters (not used in this calculation).\n        \n    Returns:\n        float: The calculated identity tension score, or None if the\n               necessary data is missing or invalid.\n    \"\"\"\n    import pandas as pd\n    import numpy as np\n    \n    try:\n        # Based on the description \"Conflict between tribal dominance and\n        # individual dignity dimensions\", we infer these column names.\n        tribal_dominance = data['tribal_dominance']\n        individual_dignity = data['individual_dignity']\n\n        # Ensure both values are present and are numeric types\n        if pd.isna(tribal_dominance) or pd.isna(individual_dignity):\n            return None\n\n        # The formula for tension between two values A and B is (A + B) - abs(A - B).\n        # This value is maximized when A and B are equal and high.\n        # It equals zero if either A or B is zero.\n        tension = (tribal_dominance + individual_dignity) - abs(tribal_dominance - individual_dignity)\n        \n        return float(tension)\n\n    except (KeyError, TypeError, AttributeError):\n        # KeyError: If 'tribal_dominance' or 'individual_dignity' columns do not exist.\n        # TypeError: If the data in the columns is not numeric.\n        # AttributeError: If `data` is not a Series/dict-like object.\n        return None\n    except Exception:\n        # A catch-all for any other unforeseen errors.\n        return None\n\ndef calculate_emotional_balance(data, **kwargs):\n    \"\"\"\n    Calculate emotional_balance: Difference between hope and fear scores\n    \n    Formula: emotional_balance = hope - fear\n\n    Args:\n        data (pd.Series): A single row of data from a pandas DataFrame.\n        **kwargs: Additional parameters (not used).\n        \n    Returns:\n        float: The calculated emotional balance, or None if input data is missing or invalid.\n    \"\"\"\n    import pandas as pd\n    import numpy as np\n    \n    try:\n        # Per instructions, using generic column names 'hope' and 'fear' as\n        # no specific names were provided in the data structure description.\n        hope_col = 'hope'\n        fear_col = 'fear'\n        \n        hope_score = data.get(hope_col)\n        fear_score = data.get(fear_col)\n        \n        # Gracefully handle missing data by checking if scores are None or NaN.\n        # pd.isna() handles both cases.\n        if pd.isna(hope_score) or pd.isna(fear_score):\n            return None\n            \n        # Calculate the difference and ensure the result is a float.\n        # A TypeError will be raised and caught if scores are not numeric.\n        result = float(hope_score) - float(fear_score)\n        \n        return result\n        \n    except (TypeError, ValueError):\n        # This block catches errors if the scores are present but not numeric\n        # (e.g., a non-convertible string), returning None as required.\n        return None\n    except Exception:\n        # A general catch-all for any other unexpected errors during execution.\n        return None\n\ndef calculate_success_climate(data, **kwargs):\n    \"\"\"\n    Calculate success_climate: Difference between compersion and envy scores\n\n    Formula: success_climate = compersion - envy\n    \n    Args:\n        data: pandas DataFrame or Series with dimension scores\n        **kwargs: Additional parameters (not used)\n        \n    Returns:\n        float: Calculated result or None if insufficient data\n    \"\"\"\n    import pandas as pd\n    import numpy as np\n    \n    try:\n        # Infer column names from the calculation description\n        compersion_col = 'compersion'\n        envy_col = 'envy'\n        \n        # Convert to numeric, coercing errors to NaN (handles non-numeric/missing)\n        compersion_score = pd.to_numeric(data[compersion_col], errors='coerce')\n        envy_score = pd.to_numeric(data[envy_col], errors='coerce')\n        \n        # Check if either value is NaN, which indicates missing or invalid data\n        if pd.isna(compersion_score) or pd.isna(envy_score):\n            return None\n            \n        # Perform the calculation\n        result = compersion_score - envy_score\n        \n        return float(result)\n        \n    except (KeyError, TypeError, AttributeError):\n        # Handles cases where columns are missing or data is not a compatible type\n        return None\n    except Exception:\n        # A general catch-all for any other unexpected errors\n        return None\n\ndef calculate_relational_climate(data, **kwargs):\n    \"\"\"\n    Calculate relational_climate: Difference between amity and enmity scores.\n\n    Formula: relational_climate = amity - enmity\n\n    Args:\n        data (pd.Series): A single row of data containing the required columns.\n        **kwargs: Additional parameters (unused).\n\n    Returns:\n        float: Calculated result or None if insufficient data.\n    \"\"\"\n    import pandas as pd\n\n    try:\n        # Column names are inferred from the calculation description as per the CFF context.\n        amity_col = 'amity'\n        enmity_col = 'enmity'\n\n        # Using .get() avoids KeyError if columns are missing\n        amity_score = data.get(amity_col)\n        enmity_score = data.get(enmity_col)\n\n        # Check for missing data (None or NaN) in the required columns\n        if pd.isna(amity_score) or pd.isna(enmity_score):\n            return None\n\n        # Ensure values are numeric and perform the calculation\n        result = float(amity_score) - float(enmity_score)\n\n        return result\n\n    except (TypeError, ValueError):\n        # Return None if scores are not numeric or another error occurs\n        return None\n\ndef calculate_goal_orientation(data, **kwargs):\n    \"\"\"\n    Calculate goal_orientation: Difference between cohesive goals and fragmentative goals\n    \n    Formula: goal_orientation = cohesive_goals - fragmentative_goals\n\n    Args:\n        data (pd.Series or pd.DataFrame): A single row of analysis data.\n        **kwargs: Additional parameters (not used).\n        \n    Returns:\n        float: The calculated goal orientation score, or None if input data is missing or invalid.\n    \"\"\"\n    import pandas as pd\n    import numpy as np\n    \n    try:\n        cohesive_col = 'cohesive_goals'\n        fragmentative_col = 'fragmentative_goals'\n\n        # Ensure the input is a pandas Series for consistent access\n        if isinstance(data, pd.DataFrame):\n            if data.shape[0] != 1:\n                # Handle DataFrame with more than one row if necessary,\n                # but for a single calculation, we expect one row.\n                # Returning None as a safe default.\n                return None\n            data = data.iloc[0]\n\n        # Check for the existence of required columns\n        if cohesive_col not in data.index or fragmentative_col not in data.index:\n            return None\n\n        # Safely convert to numeric, coercing errors to NaN\n        cohesive_score = pd.to_numeric(data[cohesive_col], errors='coerce')\n        fragmentative_score = pd.to_numeric(data[fragmentative_col], errors='coerce')\n\n        # Check if scores are valid numbers (not NaN)\n        if pd.isna(cohesive_score) or pd.isna(fragmentative_score):\n            return None\n        \n        # Calculate the difference\n        result = float(cohesive_score - fragmentative_score)\n        \n        return result\n\n    except (AttributeError, TypeError, KeyError):\n        # Handle cases where data is not in the expected format (e.g., not a Series/DataFrame)\n        return None\n    except Exception:\n        # Catch any other unexpected errors\n        return None\n\ndef calculate_overall_cohesion_index(data, **kwargs):\n    \"\"\"\n    Calculate overall_cohesion_index: Comprehensive measure combining all dimensions\n    \n    Formula: mean(all available numeric dimensions)\n    \n    Args:\n        data: pandas DataFrame or Series with dimension scores. If a DataFrame,\n              the first row will be used.\n        **kwargs: Additional parameters (unused).\n        \n    Returns:\n        float: Calculated result or None if insufficient data.\n    \"\"\"\n    import pandas as pd\n    import numpy as np\n    \n    try:\n        if isinstance(data, pd.DataFrame):\n            if data.empty:\n                return None\n            record = data.iloc[0]\n        elif isinstance(data, pd.Series):\n            record = data\n        else:\n            # Input is not a recognizable pandas type\n            return None\n\n        if record.empty:\n            return None\n\n        # As specific dimension names are not provided, the function generically\n        # selects all numeric columns to calculate a composite index.\n        numeric_dimensions = record.select_dtypes(include=np.number)\n\n        # If there are no numeric values, a score cannot be calculated.\n        if numeric_dimensions.empty:\n            return None\n\n        # Calculate the mean of all available dimensions.\n        # The .mean() method automatically handles missing (NaN) values.\n        cohesion_index = numeric_dimensions.mean()\n\n        # If the result is NaN (e.g., all dimensions were NaN), return None.\n        if pd.isna(cohesion_index):\n            return None\n            \n        return float(cohesion_index)\n\n    except (AttributeError, IndexError, TypeError, ValueError):\n        # Catch specific pandas/numpy errors for robustness\n        return None\n    except Exception:\n        # Catch any other unexpected errors\n        return None\n\ndef calculate_all_derived_metrics(data: pd.DataFrame) -> Dict[str, Optional[float]]:\n    \"\"\"\n    Calculate all derived metrics for the given dataset.\n    \n    Args:\n        data: pandas DataFrame with dimension scores\n        \n    Returns:\n        Dictionary mapping metric names to calculated values\n    \"\"\"\n    results = {}\n    \n    # Get all calculation functions from this module\n    import inspect\n    current_module = inspect.getmodule(inspect.currentframe())\n    \n    for name, obj in inspect.getmembers(current_module):\n        if (inspect.isfunction(obj) and \n            name.startswith('calculate_') and \n            name not in ['calculate_all_derived_metrics', 'calculate_derived_metrics']):\n            try:\n                results[name.replace('calculate_', '')] = obj(data)\n            except Exception as e:\n                results[name.replace('calculate_', '')] = None\n                \n    return results\n\n\ndef calculate_derived_metrics(data: pd.DataFrame) -> pd.DataFrame:\n    \"\"\"\n    Template-compatible wrapper function for derived metrics calculation.\n    \n    This function is called by the universal notebook template and returns\n    the original data with additional derived metric columns.\n    \n    Args:\n        data: pandas DataFrame with dimension scores\n        \n    Returns:\n        DataFrame with original data plus derived metric columns\n    \"\"\"\n    # Calculate all derived metrics\n    derived_metrics = calculate_all_derived_metrics(data)\n    \n    # Create a copy of the original data\n    result = data.copy()\n    \n    # Add derived metrics as new columns\n    for metric_name, metric_value in derived_metrics.items():\n        if metric_value is not None:\n            # For scalar metrics, broadcast to all rows\n            result[metric_name] = metric_value\n        else:\n            # For failed calculations, use NaN\n            result[metric_name] = np.nan\n    \n    return result\n",
  "cached_with_code": true
}