{
  "status": "success",
  "functions_generated": 6,
  "output_file": "automatedderivedmetricsagent_functions.py",
  "module_size": 14302,
  "function_code_content": "\"\"\"\nAutomated Derived Metrics Functions\n===================================\n\nGenerated by AutomatedDerivedMetricsAgent for experiment: Test Experiment\nDescription: Test experiment for derived metrics\nGenerated: 2025-08-25T03:15:42.761709+00:00\n\nThis module contains automatically generated calculation functions for derived metrics\nas specified in the framework's natural language descriptions.\n\"\"\"\n\nimport pandas as pd\nimport numpy as np\nfrom typing import Optional, Dict, Any\n\n\ndef calculate_identity_tension(data, **kwargs):\n    \"\"\"\n    Calculate identity_tension: Conflict between tribal dominance and individual dignity dimensions.\n\n    This calculation models the tension as an interaction between two competing\n    dimensions. The tension is considered highest when appeals to both tribal\n    dominance and individual dignity are strong. The product of the two scores\n    effectively captures this, as the result is maximized only when both inputs\n    are high.\n\n    Formula: tribal_dominance * individual_dignity\n\n    Args:\n        data (pd.Series): A single row of data from a pandas DataFrame.\n        **kwargs: Additional keyword arguments (not used).\n\n    Returns:\n        float: The calculated identity tension score, or None if necessary\n               columns are missing or contain invalid data.\n    \"\"\"\n    import pandas as pd\n    import numpy as np\n\n    try:\n        # Column names are derived from the dimension names in the description.\n        # This requires 'tribal_dominance' and 'individual_dignity' scores to be present.\n        tribal_score = data['tribal_dominance']\n        dignity_score = data['individual_dignity']\n\n        # Ensure both scores are valid numbers before calculation.\n        if pd.isna(tribal_score) or pd.isna(dignity_score):\n            return None\n\n        # Calculate the product to represent the interaction tension.\n        result = float(tribal_score * dignity_score)\n        \n        return result\n\n    except (KeyError, TypeError):\n        # A KeyError will be raised if the required columns are not in the data.\n        # A TypeError will be raised if the data is not numeric.\n        # In either case, the calculation cannot proceed.\n        return None\n\ndef calculate_emotional_balance(data, **kwargs):\n    \"\"\"\n    Calculate emotional_balance: Difference between hope and fear scores\n    Formula: hope_score - fear_score\n    \n    Args:\n        data: pandas DataFrame with dimension scores (treated as a single row/Series)\n        **kwargs: Additional parameters\n        \n    Returns:\n        float: Calculated result or None if insufficient data\n    \"\"\"\n    import pandas as pd\n    import numpy as np\n    \n    try:\n        # Despite \"no column names given\", the calculation name implies them.\n        # We use sensible defaults and allow overrides via kwargs for robustness.\n        hope_col = kwargs.get('hope_col', 'hope_score')\n        fear_col = kwargs.get('fear_col', 'fear_score')\n\n        # Ensure required columns are present in the data object.\n        # This check works for both pandas Series (checks index) and DataFrames (checks columns).\n        if hope_col not in data or fear_col not in data:\n            return None\n\n        # Retrieve scores from the data object.\n        hope_score = data[hope_col]\n        fear_score = data[fear_col]\n\n        # Gracefully handle missing data points (e.g., NaN, None).\n        if pd.isna(hope_score) or pd.isna(fear_score):\n            return None\n\n        # Perform the calculation, ensuring values are treated as numeric.\n        result = float(hope_score) - float(fear_score)\n\n        # A non-finite result (inf, -inf, nan) is not a valid balance.\n        if not np.isfinite(result):\n            return None\n        \n        return result\n\n    except (ValueError, TypeError, KeyError):\n        # ValueError/TypeError: if values are not convertible to float.\n        # KeyError: if a column is missing (as a fallback).\n        return None\n    except Exception:\n        # Catch any other unexpected errors to ensure stability.\n        return None\n\ndef calculate_success_climate(data, **kwargs):\n    \"\"\"\n    Calculate success_climate: Difference between compersion and envy scores\n\n    Formula: success_climate = compersion - envy\n    \n    Args:\n        data (pd.Series): A single row of data containing the dimension scores.\n        **kwargs: Additional parameters (unused).\n        \n    Returns:\n        float: The calculated score, or None if required data is missing.\n    \"\"\"\n    import pandas as pd\n\n    try:\n        # Column names 'compersion' and 'envy' are inferred from the calculation description,\n        # as no specific data structure was provided.\n        compersion_score = data['compersion']\n        envy_score = data['envy']\n\n        # The calculation requires both values to be present.\n        if pd.isna(compersion_score) or pd.isna(envy_score):\n            return None\n\n        # Calculate the difference and ensure the result is a float.\n        return float(compersion_score - envy_score)\n\n    except Exception:\n        # This broad exception handles cases where columns are missing (KeyError),\n        # data is non-numeric (TypeError), or other unexpected errors occur.\n        return None\n\ndef calculate_relational_climate(data, **kwargs):\n    \"\"\"\n    Calculate relational_climate: Difference between amity and enmity scores\n\n    Formula: relational_climate = amity - enmity\n\n    Args:\n        data (pd.Series): A single row of data from a pandas DataFrame\n                          containing 'amity' and 'enmity' columns.\n        **kwargs: Additional parameters (not used).\n\n    Returns:\n        float: The calculated relational climate score, or None if\n               the required data is missing or invalid.\n    \"\"\"\n    import pandas as pd\n    import numpy as np\n\n    try:\n        # Based on the description, the calculation requires 'amity' and 'enmity' scores.\n        # These are assumed to be the column names.\n        amity_score = data['amity']\n        enmity_score = data['enmity']\n\n        # Handle missing data gracefully\n        if pd.isna(amity_score) or pd.isna(enmity_score):\n            return None\n\n        # Ensure data is numeric before calculation\n        amity_score = float(amity_score)\n        enmity_score = float(enmity_score)\n\n        # Calculate the difference\n        relational_climate = amity_score - enmity_score\n        \n        return relational_climate\n\n    except (KeyError, TypeError, ValueError):\n        # Handle cases where columns are missing or data is not numeric\n        return None\n    except Exception:\n        # A general catch-all for any other unexpected errors\n        return None\n\ndef calculate_goal_orientation(data, **kwargs):\n    \"\"\"\n    Calculate goal_orientation: Difference between cohesive goals and fragmentative goals\n\n    Formula: goal_orientation = cohesive_goals - fragmentative_goals\n\n    Args:\n        data (pd.Series): A single row of data from a DataFrame.\n        **kwargs: Additional parameters (not used).\n\n    Returns:\n        float: Calculated result or None if insufficient data or errors occur.\n    \"\"\"\n    import pandas as pd\n    import numpy as np\n\n    try:\n        # Per instruction, generic column names are derived from the calculation description.\n        cohesive_col = 'cohesive_goals'\n        fragmentative_col = 'fragmentative_goals'\n\n        # Ensure required columns are present in the data (works for Series)\n        if cohesive_col not in data or fragmentative_col not in data:\n            return None\n\n        cohesive_value = data[cohesive_col]\n        fragmentative_value = data[fragmentative_col]\n\n        # Handle missing data (e.g., NaN) gracefully\n        if pd.isna(cohesive_value) or pd.isna(fragmentative_value):\n            return None\n\n        # Perform the calculation, ensuring values are numeric\n        result = float(cohesive_value) - float(fragmentative_value)\n\n        return result\n\n    except (TypeError, ValueError):\n        # This handles cases where data might not be numeric\n        return None\n    except Exception:\n        # A general catch-all for any other unexpected errors\n        return None\n\ndef calculate_overall_cohesion_index(data, **kwargs):\n    \"\"\"\n    Calculate overall_cohesion_index: Comprehensive measure combining all dimensions.\n\n    This index measures the overall balance between discourse elements that\n    promote social cohesion and those that detract from it. It is calculated as\n    the difference between the average of cohesion-promoting scores and the\n    average of cohesion-detracting scores.\n\n    A positive value indicates a net cohesive discourse, while a negative value\n    indicates a net divisive discourse. A value of zero suggests a balance or\n    the absence of strong cohesive/divisive elements.\n\n    Formula:\n    mean(Cohesive Dimension Scores) - mean(Divisive Dimension Scores)\n\n    Note: As specific column names were not provided in the framework, this function\n    uses plausible generic names derived from the framework's description. It will\n    only use the columns that are actually present in the provided data.\n\n    Generic Cohesive Dimensions:\n    - social_solidarity_score\n    - institutional_trust_score\n    - hope_appeal_score\n    - constructive_engagement_score\n\n    Generic Divisive Dimensions:\n    - social_fragmentation_score\n    - institutional_distrust_score\n    - fear_appeal_score\n    - othering_score\n\n    Args:\n        data (pd.Series or pd.DataFrame): A single row of data (as a Series or a\n                                          single-row DataFrame) containing the\n                                          dimension scores.\n        **kwargs: Additional keyword arguments (not used in this calculation).\n\n    Returns:\n        float: The calculated Overall Cohesion Index, or None if insufficient\n               or invalid data is provided.\n    \"\"\"\n    import pandas as pd\n\n    cohesive_dimensions = [\n        'social_solidarity_score',\n        'institutional_trust_score',\n        'hope_appeal_score',\n        'constructive_engagement_score'\n    ]\n    divisive_dimensions = [\n        'social_fragmentation_score',\n        'institutional_distrust_score',\n        'fear_appeal_score',\n        'othering_score'\n    ]\n\n    try:\n        # Ensure 'data' is a pandas Series for consistent processing\n        if isinstance(data, pd.DataFrame):\n            if len(data) != 1:\n                # This function is designed for single-row analysis\n                return None\n            data = data.iloc[0]\n\n        if not isinstance(data, pd.Series):\n            return None\n\n        # Identify which of the potential dimension columns are present in the data\n        available_cohesive_cols = [col for col in cohesive_dimensions if col in data.index]\n        available_divisive_cols = [col for col in divisive_dimensions if col in data.index]\n\n        # If no relevant columns exist in the data, a score cannot be calculated\n        if not available_cohesive_cols and not available_divisive_cols:\n            return None\n\n        # Calculate the mean for each group of dimensions.\n        # pd.to_numeric with errors='coerce' handles non-numeric values gracefully.\n        # The .mean() method automatically ignores NaN values.\n        cohesive_scores = pd.to_numeric(data.get(available_cohesive_cols), errors='coerce')\n        divisive_scores = pd.to_numeric(data.get(available_divisive_cols), errors='coerce')\n\n        mean_cohesive = cohesive_scores.mean()\n        mean_divisive = divisive_scores.mean()\n\n        # If both means are NaN, it means no valid numeric data was found in any\n        # of the relevant columns.\n        if pd.isna(mean_cohesive) and pd.isna(mean_divisive):\n            return None\n\n        # If a group had no columns or only NaN values, its mean will be NaN.\n        # In the final calculation, treat such a group as having a zero score.\n        mean_cohesive = 0.0 if pd.isna(mean_cohesive) else mean_cohesive\n        mean_divisive = 0.0 if pd.isna(mean_divisive) else mean_divisive\n\n        overall_index = mean_cohesive - mean_divisive\n\n        return float(overall_index)\n\n    except (AttributeError, KeyError, TypeError, ValueError):\n        # Gracefully handle errors from malformed data or pandas operations\n        return None\n    except Exception:\n        # Catch any other unexpected errors during execution\n        return None\n\ndef calculate_all_derived_metrics(data: pd.DataFrame) -> Dict[str, Optional[float]]:\n    \"\"\"\n    Calculate all derived metrics for the given dataset.\n    \n    Args:\n        data: pandas DataFrame with dimension scores\n        \n    Returns:\n        Dictionary mapping metric names to calculated values\n    \"\"\"\n    results = {}\n    \n    # Get all calculation functions from this module\n    import inspect\n    current_module = inspect.getmodule(inspect.currentframe())\n    \n    for name, obj in inspect.getmembers(current_module):\n        if (inspect.isfunction(obj) and \n            name.startswith('calculate_') and \n            name not in ['calculate_all_derived_metrics', 'calculate_derived_metrics']):\n            try:\n                results[name.replace('calculate_', '')] = obj(data)\n            except Exception as e:\n                results[name.replace('calculate_', '')] = None\n                \n    return results\n\n\ndef calculate_derived_metrics(data: pd.DataFrame) -> pd.DataFrame:\n    \"\"\"\n    Template-compatible wrapper function for derived metrics calculation.\n    \n    This function is called by the universal notebook template and returns\n    the original data with additional derived metric columns.\n    \n    Args:\n        data: pandas DataFrame with dimension scores\n        \n    Returns:\n        DataFrame with original data plus derived metric columns\n    \"\"\"\n    # Calculate all derived metrics\n    derived_metrics = calculate_all_derived_metrics(data)\n    \n    # Create a copy of the original data\n    result = data.copy()\n    \n    # Add derived metrics as new columns\n    for metric_name, metric_value in derived_metrics.items():\n        if metric_value is not None:\n            # For scalar metrics, broadcast to all rows\n            result[metric_name] = metric_value\n        else:\n            # For failed calculations, use NaN\n            result[metric_name] = np.nan\n    \n    return result\n",
  "cached_with_code": true
}