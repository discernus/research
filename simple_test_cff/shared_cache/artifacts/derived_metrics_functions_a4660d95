{
  "status": "success",
  "functions_generated": 6,
  "output_file": "automatedderivedmetricsagent_functions.py",
  "module_size": 12338,
  "function_code_content": "\"\"\"\nAutomated Derived Metrics Functions\n===================================\n\nGenerated by AutomatedDerivedMetricsAgent for experiment: Test Experiment\nDescription: Test experiment for derived metrics\nGenerated: 2025-08-25T03:50:55.986419+00:00\n\nThis module contains automatically generated calculation functions for derived metrics\nas specified in the framework's natural language descriptions.\n\"\"\"\n\nimport pandas as pd\nimport numpy as np\nfrom typing import Optional, Dict, Any\n\n\ndef calculate_identity_tension(data, **kwargs):\n    \"\"\"\n    Calculate identity_tension: Conflict between tribal dominance and individual dignity dimensions.\n\n    This metric is highest when both tribal dominance and individual dignity are simultaneously high,\n    indicating a direct rhetorical conflict. The calculation measures the degree of this co-occurrence,\n    reflecting the CFF's principle of analyzing competing appeals.\n\n    Formula:\n    (tribal_dominance + individual_dignity) - abs(tribal_dominance - individual_dignity)\n    This is equivalent to: 2 * min(tribal_dominance, individual_dignity)\n\n    Args:\n        data (pd.Series):\n            A row of data with dimension scores.\n            Required columns are inferred from the description as 'tribal_dominance' and 'individual_dignity'.\n        **kwargs:\n            Additional parameters (not used in this calculation).\n\n    Returns:\n        float: Calculated result or None if insufficient data or required columns are missing.\n    \"\"\"\n    import pandas as pd\n    import numpy as np\n\n    try:\n        # Column names are inferred from the calculation's description as no explicit names were provided.\n        tribal_score = data['tribal_dominance']\n        dignity_score = data['individual_dignity']\n\n        if pd.isna(tribal_score) or pd.isna(dignity_score):\n            return None\n\n        # The formula (a + b) - abs(a - b) is a robust way to calculate 2 * min(a, b).\n        # It measures the \"intersection\" or simultaneous presence of both dimensions.\n        # Tension is high only when both scores are high.\n        tension = (tribal_score + dignity_score) - np.abs(tribal_score - dignity_score)\n\n        return float(tension)\n\n    except (KeyError, TypeError, AttributeError):\n        # Handles missing columns, incorrect data types, or other access errors.\n        return None\n    except Exception:\n        # A general catch-all for any other unexpected errors.\n        return None\n\ndef calculate_emotional_balance(data, **kwargs):\n    \"\"\"\n    Calculate emotional_balance: Difference between hope and fear scores\n    Formula: emotional_balance = hope - fear\n\n    Args:\n        data (pd.Series): A single row of data from a pandas DataFrame.\n        **kwargs: Additional parameters (unused).\n\n    Returns:\n        float: Calculated result or None if insufficient data.\n    \"\"\"\n    import pandas as pd\n    import numpy as np\n\n    try:\n        # The calculation is based on 'hope' and 'fear' scores, which are the\n        # most logical column names derived from the description.\n        hope_score = data['hope']\n        fear_score = data['fear']\n\n        # Handle missing data gracefully by checking if either score is null/NaN.\n        if pd.isna(hope_score) or pd.isna(fear_score):\n            return None\n\n        # Calculate the difference and ensure the output is a standard float.\n        result = float(hope_score - fear_score)\n        return result\n\n    except Exception:\n        # A broad exception catch handles potential KeyErrors (missing columns),\n        # TypeErrors (non-numeric data), or other unexpected issues.\n        return None\n\ndef calculate_success_climate(data, **kwargs):\n    \"\"\"\n    Calculate success_climate: Difference between compersion and envy scores\n    \n    Formula: success_climate = compersion - envy\n    \n    Args:\n        data (pd.Series or pd.DataFrame): A single row of data containing the required columns.\n        **kwargs: Additional parameters (unused).\n        \n    Returns:\n        float: Calculated result or None if insufficient data.\n    \"\"\"\n    import pandas as pd\n    \n    try:\n        compersion_score = data['compersion']\n        envy_score = data['envy']\n        \n        # Check for missing values (None, NaN, etc.)\n        if pd.isna(compersion_score) or pd.isna(envy_score):\n            return None\n            \n        # Ensure scores are numeric before calculation\n        result = float(compersion_score) - float(envy_score)\n        return result\n        \n    except (KeyError, TypeError, ValueError):\n        # KeyError: If 'compersion' or 'envy' columns are missing.\n        # TypeError: If data is not in a format that supports item access (e.g., not a Series/dict).\n        # ValueError: If scores cannot be converted to float.\n        return None\n\ndef calculate_relational_climate(data, **kwargs):\n    \"\"\"\n    Calculate relational_climate: Difference between amity and enmity scores.\n\n    Formula: relational_climate = amity - enmity\n\n    Args:\n        data (pd.Series or dict): A single row of data containing the necessary columns.\n        **kwargs: Additional keyword arguments (unused in this calculation).\n\n    Returns:\n        float: The calculated relational climate score, or None if the necessary\n               data ('amity', 'enmity') is missing or non-numeric.\n    \"\"\"\n    import pandas as pd\n    import numpy as np\n\n    try:\n        # Accessor for both Series and dictionary-like objects\n        amity_score = data.get('amity')\n        enmity_score = data.get('enmity')\n\n        # Check for missing columns or non-numeric data\n        if pd.isnull(amity_score) or pd.isnull(enmity_score):\n            return None\n        \n        # Ensure values are numeric before calculation\n        if not isinstance(amity_score, (int, float, np.number)) or not isinstance(enmity_score, (int, float, np.number)):\n            return None\n\n        # Calculate the difference\n        relational_climate = float(amity_score) - float(enmity_score)\n        \n        return relational_climate\n\n    except (TypeError, KeyError, AttributeError):\n        # Catch potential errors if data is not in the expected format\n        return None\n    except Exception:\n        # A general catch-all for any other unexpected errors\n        return None\n\ndef calculate_goal_orientation(data, **kwargs):\n    \"\"\"\n    Calculate goal_orientation: Difference between cohesive goals and fragmentative goals\n\n    Formula: goal_orientation = cohesive_goals - fragmentative_goals\n\n    Args:\n        data (pd.Series): A row of data containing the necessary columns.\n        **kwargs: Additional keyword arguments (not used).\n\n    Returns:\n        float: The calculated score, or None if data is missing or invalid.\n    \"\"\"\n    import pandas as pd\n\n    try:\n        # Based on the calculation description, the required columns are inferred.\n        cohesive_col = 'cohesive_goals'\n        fragmentative_col = 'fragmentative_goals'\n\n        cohesive_score = data[cohesive_col]\n        fragmentative_score = data[fragmentative_col]\n\n        # Attempt to convert scores to float. This will raise a ValueError\n        # for non-numeric types, which is caught below.\n        # The subtraction itself will result in NaN if either input is NaN.\n        result = float(cohesive_score) - float(fragmentative_score)\n\n        # Check if the result is NaN (due to missing inputs) and return None if so.\n        # Otherwise, return the calculated float result.\n        return None if pd.isna(result) else result\n\n    except (KeyError, TypeError, ValueError):\n        # This handles several failure cases gracefully:\n        # KeyError: If the required columns do not exist in the data.\n        # TypeError/ValueError: If the data in the columns is not numeric.\n        return None\n    except Exception:\n        # A general catch-all for any other unexpected errors.\n        return None\n\ndef calculate_overall_cohesion_index(data, **kwargs):\n    \"\"\"\n    Calculate overall_cohesion_index: Comprehensive measure combining all dimensions.\n\n    This index provides a holistic score of a text's contribution to social cohesion by\n    averaging the primary dimensional indices of the Cohesive Flourishing Framework.\n    It synthesizes measures of constructive dialogue, social fabric, and democratic\n    health into a single, high-level metric.\n\n    Formula:\n    mean(constructive_discourse_index, social_fabric_index, democratic_health_index)\n\n    Args:\n        data (pd.Series or pd.DataFrame): A single row of analysis data\n            containing the required component indices.\n        **kwargs: Not used.\n\n    Returns:\n        float: The calculated overall cohesion index, or None if any of the\n               required component indices are missing or null.\n    \"\"\"\n    import pandas as pd\n    import numpy as np\n\n    try:\n        # Ensure data is a single Series for consistent processing\n        if isinstance(data, pd.DataFrame):\n            if len(data) != 1:\n                # This function is designed to operate on a single row/document\n                return None\n            series = data.iloc[0]\n        elif isinstance(data, pd.Series):\n            series = data\n        else:\n            # Input is not in a recognizable pandas format\n            return None\n\n        # As per the framework description, the overall index aggregates key sub-indices.\n        # These names are chosen as logical representations of the framework's goals.\n        required_columns = [\n            'constructive_discourse_index',\n            'social_fabric_index',\n            'democratic_health_index'\n        ]\n\n        # Check for the presence of all necessary columns\n        if not all(col in series.index for col in required_columns):\n            return None\n\n        # Extract values for the component indices\n        component_values = [series[col] for col in required_columns]\n\n        # If any component value is null, the overall index cannot be calculated\n        if any(pd.isnull(value) for value in component_values):\n            return None\n\n        # Calculate the mean of the component indices\n        overall_index = np.mean(component_values)\n\n        return float(overall_index)\n\n    except (AttributeError, KeyError, TypeError, IndexError):\n        # Catch errors related to missing columns, incorrect data types, or empty data\n        return None\n    except Exception:\n        # Catch any other unexpected errors\n        return None\n\ndef calculate_all_derived_metrics(data: pd.DataFrame) -> Dict[str, Optional[float]]:\n    \"\"\"\n    Calculate all derived metrics for the given dataset.\n    \n    Args:\n        data: pandas DataFrame with dimension scores\n        \n    Returns:\n        Dictionary mapping metric names to calculated values\n    \"\"\"\n    results = {}\n    \n    # Get all calculation functions from this module\n    import inspect\n    current_module = inspect.getmodule(inspect.currentframe())\n    \n    for name, obj in inspect.getmembers(current_module):\n        if (inspect.isfunction(obj) and \n            name.startswith('calculate_') and \n            name not in ['calculate_all_derived_metrics', 'calculate_derived_metrics']):\n            try:\n                results[name.replace('calculate_', '')] = obj(data)\n            except Exception as e:\n                results[name.replace('calculate_', '')] = None\n                \n    return results\n\n\ndef calculate_derived_metrics(data: pd.DataFrame) -> pd.DataFrame:\n    \"\"\"\n    Template-compatible wrapper function for derived metrics calculation.\n    \n    This function is called by the universal notebook template and returns\n    the original data with additional derived metric columns.\n    \n    Args:\n        data: pandas DataFrame with dimension scores\n        \n    Returns:\n        DataFrame with original data plus derived metric columns\n    \"\"\"\n    # Calculate all derived metrics\n    derived_metrics = calculate_all_derived_metrics(data)\n    \n    # Create a copy of the original data\n    result = data.copy()\n    \n    # Add derived metrics as new columns\n    for metric_name, metric_value in derived_metrics.items():\n        if metric_value is not None:\n            # For scalar metrics, broadcast to all rows\n            result[metric_name] = metric_value\n        else:\n            # For failed calculations, use NaN\n            result[metric_name] = np.nan\n    \n    return result\n",
  "cached_with_code": true
}