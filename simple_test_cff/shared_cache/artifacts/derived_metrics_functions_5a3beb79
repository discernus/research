{
  "status": "success",
  "functions_generated": 6,
  "output_file": "automatedderivedmetricsagent_functions.py",
  "module_size": 12821,
  "function_code_content": "\"\"\"\nAutomated Derived Metrics Functions\n===================================\n\nGenerated by AutomatedDerivedMetricsAgent for experiment: Test Experiment\nDescription: Test experiment for derived metrics\nGenerated: 2025-08-24T03:45:39.806253+00:00\n\nThis module contains automatically generated calculation functions for derived metrics\nas specified in the framework's natural language descriptions.\n\"\"\"\n\nimport pandas as pd\nimport numpy as np\nfrom typing import Optional, Dict, Any\n\n\ndef calculate_identity_tension(data, **kwargs):\n    \"\"\"\n    Calculate identity_tension: Conflict between tribal dominance and individual dignity dimensions\n\n    This function measures the tension between two competing identity dimensions. The tension is\n    maximized when both dimensions have high and equal scores, indicating a strong internal\n    conflict in the discourse. It assumes scores are normalized between 0 and 1.\n\n    Formula:\n    tension = ((tribal_dominance + individual_dignity) / 2) * (1 - abs(tribal_dominance - individual_dignity))\n\n    Args:\n        data (pd.Series): A single row of data containing the necessary dimension scores.\n        **kwargs: Additional parameters (unused).\n\n    Returns:\n        float: The calculated identity tension score, or None if necessary data is missing or invalid.\n    \"\"\"\n    import pandas as pd\n    import numpy as np\n\n    try:\n        # The calculation is described as a conflict between \"tribal dominance\" and \"individual dignity\".\n        # We infer these are the required column names based on the description.\n        tribal_dominance = data['tribal_dominance']\n        individual_dignity = data['individual_dignity']\n\n        # Ensure necessary data is present\n        if pd.isna(tribal_dominance) or pd.isna(individual_dignity):\n            return None\n\n        # The tension formula is highest when both scores are high and close together.\n        # It calculates the average of the scores and penalizes it by their difference.\n        average_score = (tribal_dominance + individual_dignity) / 2.0\n        absolute_difference = abs(tribal_dominance - individual_dignity)\n\n        # The (1 - absolute_difference) term is maximized when the scores are equal.\n        tension = average_score * (1 - absolute_difference)\n\n        return float(tension)\n\n    except (KeyError, TypeError):\n        # Handle cases where columns are missing or data types are incorrect\n        return None\n\ndef calculate_emotional_balance(data, **kwargs):\n    \"\"\"\n    Calculate emotional_balance: Difference between hope and fear scores\n\n    Formula: hope_score - fear_score\n    \n    Args:\n        data (pd.Series): A single row of data with dimension scores.\n        **kwargs: Additional keyword arguments (not used).\n        \n    Returns:\n        float: Calculated result or None if insufficient data.\n    \"\"\"\n    import pandas as pd\n    import numpy as np\n    \n    try:\n        hope_col = 'hope_score'\n        fear_col = 'fear_score'\n\n        # Ensure necessary columns are present in the data (works for Series/DataFrame row)\n        if hope_col not in data.index or fear_col not in data.index:\n            return None\n\n        hope_score = data[hope_col]\n        fear_score = data[fear_col]\n\n        # Check for missing or non-numeric data\n        if pd.isna(hope_score) or pd.isna(fear_score):\n            return None\n        \n        # Convert to numeric types for calculation, handling potential errors\n        hope_score = float(hope_score)\n        fear_score = float(fear_score)\n\n        # Calculate the difference\n        emotional_balance = hope_score - fear_score\n        \n        return emotional_balance\n\n    except (KeyError, TypeError, ValueError):\n        # Handle missing keys, incorrect data types, or non-convertible values\n        return None\n    except Exception:\n        # A general catch-all for any other unexpected errors\n        return None\n\ndef calculate_success_climate(data, **kwargs):\n    \"\"\"\n    Calculate success_climate: Difference between compersion and envy scores.\n\n    Formula: success_climate = compersion - envy\n    \n    Args:\n        data (pd.Series): A row of data containing compersion and envy scores.\n        **kwargs: Additional keyword arguments (not used in this calculation).\n        \n    Returns:\n        float: The calculated success climate score, or None if input data is\n               missing or invalid.\n    \"\"\"\n    import pandas as pd\n\n    try:\n        # Per the description, the calculation requires 'compersion' and 'envy' scores.\n        # As no column names were provided, we infer them directly from the dimension names.\n        compersion_score = data['compersion']\n        envy_score = data['envy']\n\n        # Handle missing data gracefully by checking for NaN or None\n        if pd.isna(compersion_score) or pd.isna(envy_score):\n            return None\n\n        # Ensure scores are numeric and perform the calculation\n        result = float(compersion_score) - float(envy_score)\n        \n        return result\n\n    except (KeyError, TypeError, ValueError):\n        # KeyError: if 'compersion' or 'envy' columns do not exist.\n        # TypeError: if 'data' is not a subscriptable object (e.g., NoneType).\n        # ValueError: if scores are not convertible to float.\n        return None\n\ndef calculate_relational_climate(data, **kwargs):\n    \"\"\"\n    Calculate relational_climate: Difference between amity and enmity scores\n\n    Formula: relational_climate = amity - enmity\n\n    Args:\n        data (pd.Series): A row of data containing 'amity' and 'enmity' scores.\n        **kwargs: Additional keyword arguments (not used).\n\n    Returns:\n        float: The calculated score, or None if input data is missing or invalid.\n    \"\"\"\n    import pandas as pd\n\n    try:\n        # Retrieve scores using .get() to handle missing columns gracefully.\n        # pd.to_numeric with errors='coerce' will convert non-numeric values\n        # and None (from missing columns) into NaN (Not a Number).\n        amity_score = pd.to_numeric(data.get('amity'), errors='coerce')\n        enmity_score = pd.to_numeric(data.get('enmity'), errors='coerce')\n\n        # If either score is NaN (due to missing column, None value, or\n        # non-numeric data), the calculation is not possible.\n        if pd.isna(amity_score) or pd.isna(enmity_score):\n            return None\n\n        # Perform the calculation\n        result = float(amity_score - enmity_score)\n\n        return result\n\n    except (AttributeError, TypeError):\n        # This will catch errors if `data` is not a pandas Series or dict-like\n        # object that supports the .get() method.\n        return None\n    except Exception:\n        # A general fallback for any other unexpected errors.\n        return None\n\ndef calculate_goal_orientation(data, **kwargs):\n    \"\"\"\n    Calculate goal_orientation: Difference between cohesive goals and fragmentative goals\n\n    Formula: cohesive_goals - fragmentative_goals\n\n    Args:\n        data (pd.Series): A single row of analysis data containing dimension scores.\n        **kwargs: Additional parameters (not used).\n\n    Returns:\n        float: Calculated result or None if insufficient data.\n    \"\"\"\n    import pandas as pd\n    import numpy as np\n\n    try:\n        cohesive_col = 'cohesive_goals'\n        fragmentative_col = 'fragmentative_goals'\n\n        # Extract scores from the data Series\n        cohesive_score = data[cohesive_col]\n        fragmentative_score = data[fragmentative_col]\n\n        # Check for missing values (NaN, None) before calculation\n        if pd.isna(cohesive_score) or pd.isna(fragmentative_score):\n            return None\n\n        # Perform the calculation\n        result = float(cohesive_score - fragmentative_score)\n\n        # Ensure the result is a finite number (not inf, -inf, or nan)\n        if not np.isfinite(result):\n            return None\n\n        return result\n    except Exception:\n        # Catches KeyError if columns are missing, TypeError if data is non-numeric,\n        # or any other unexpected errors.\n        return None\n\ndef calculate_overall_cohesion_index(data, **kwargs):\n    \"\"\"\n    Calculate overall_cohesion_index: Comprehensive measure combining all dimensions.\n\n    This function computes a holistic score representing the overall state of\n    social cohesion as defined by the Cohesive Flourishing Framework. It is\n    calculated as the arithmetic mean of the primary sub-indices, each\n    representing a core dimension of a flourishing society.\n\n    Formula:\n    mean(\n        discourse_health_index,\n        social_fabric_index,\n        civic_vitality_index,\n        institutional_trust_index\n    )\n\n    Args:\n        data (pd.Series or pd.DataFrame): A single row of data containing\n            the necessary pre-calculated sub-indices.\n            Required columns:\n            - 'discourse_health_index': Index measuring constructive vs. destructive communication.\n            - 'social_fabric_index': Index measuring social trust, solidarity, and belonging.\n            - 'civic_vitality_index': Index measuring active and constructive citizen engagement.\n            - 'institutional_trust_index': Index measuring public confidence in shared institutions.\n\n    Returns:\n        float: The calculated Overall Cohesion Index, or None if any of the\n               required sub-indices are missing or non-numeric.\n    \"\"\"\n    import pandas as pd\n    import numpy as np\n\n    # As this function aggregates other indices, these are its dependencies.\n    # Invented based on framework description as no explicit columns were provided.\n    required_columns = [\n        'discourse_health_index',\n        'social_fabric_index',\n        'civic_vitality_index',\n        'institutional_trust_index'\n    ]\n\n    try:\n        # Handle both Series and single-row DataFrame inputs\n        if isinstance(data, pd.DataFrame):\n            if data.empty:\n                return None\n            record = data.iloc[0]\n        elif isinstance(data, pd.Series):\n            record = data\n        else:\n            # Invalid input type\n            return None\n\n        # Check for the presence of all required columns\n        if not all(col in record.index for col in required_columns):\n            return None\n\n        # Extract values, ensuring they are numeric and handling non-numeric data\n        values = pd.to_numeric(record[required_columns], errors='coerce')\n\n        # If any value is missing (NaN) after conversion, we cannot calculate the index\n        if values.isnull().any():\n            return None\n\n        # Calculate the mean of the component indices\n        overall_index = values.mean()\n\n        return float(overall_index)\n\n    except (AttributeError, TypeError, ValueError, IndexError):\n        # Catch a variety of potential errors during data processing\n        return None\n    except Exception:\n        # Broad exception for any other unforeseen issues\n        return None\n\ndef calculate_all_derived_metrics(data: pd.DataFrame) -> Dict[str, Optional[float]]:\n    \"\"\"\n    Calculate all derived metrics for the given dataset.\n    \n    Args:\n        data: pandas DataFrame with dimension scores\n        \n    Returns:\n        Dictionary mapping metric names to calculated values\n    \"\"\"\n    results = {}\n    \n    # Get all calculation functions from this module\n    import inspect\n    current_module = inspect.getmodule(inspect.currentframe())\n    \n    for name, obj in inspect.getmembers(current_module):\n        if (inspect.isfunction(obj) and \n            name.startswith('calculate_') and \n            name not in ['calculate_all_derived_metrics', 'calculate_derived_metrics']):\n            try:\n                results[name.replace('calculate_', '')] = obj(data)\n            except Exception as e:\n                results[name.replace('calculate_', '')] = None\n                \n    return results\n\n\ndef calculate_derived_metrics(data: pd.DataFrame) -> pd.DataFrame:\n    \"\"\"\n    Template-compatible wrapper function for derived metrics calculation.\n    \n    This function is called by the universal notebook template and returns\n    the original data with additional derived metric columns.\n    \n    Args:\n        data: pandas DataFrame with dimension scores\n        \n    Returns:\n        DataFrame with original data plus derived metric columns\n    \"\"\"\n    # Calculate all derived metrics\n    derived_metrics = calculate_all_derived_metrics(data)\n    \n    # Create a copy of the original data\n    result = data.copy()\n    \n    # Add derived metrics as new columns\n    for metric_name, metric_value in derived_metrics.items():\n        if metric_value is not None:\n            # For scalar metrics, broadcast to all rows\n            result[metric_name] = metric_value\n        else:\n            # For failed calculations, use NaN\n            result[metric_name] = np.nan\n    \n    return result\n",
  "cached_with_code": true
}