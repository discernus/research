{
  "status": "success",
  "functions_generated": 6,
  "output_file": "automatedderivedmetricsagent_functions.py",
  "module_size": 13096,
  "function_code_content": "\"\"\"\nAutomated Derived Metrics Functions\n===================================\n\nGenerated by AutomatedDerivedMetricsAgent for experiment: Test Experiment\nDescription: Test experiment for derived metrics\nGenerated: 2025-08-24T01:06:43.991434+00:00\n\nThis module contains automatically generated calculation functions for derived metrics\nas specified in the framework's natural language descriptions.\n\"\"\"\n\nimport pandas as pd\nimport numpy as np\nfrom typing import Optional, Dict, Any\n\n\ndef calculate_identity_tension(data, **kwargs):\n    \"\"\"\n    Calculate identity_tension: Conflict between tribal dominance and individual dignity dimensions.\n\n    This function measures the tension between two opposing social dimensions: the drive\n    for group dominance and the respect for individual dignity. The tension is modeled\n    as the geometric mean of the scores for these two dimensions. A high tension score\n    indicates that rhetoric simultaneously contains strong appeals to both tribal\n    dominance and individual dignity, creating a point of conflict or cognitive\n    dissonance. A low score indicates that one or both dimensions are weak.\n\n    Formula: sqrt(tribal_dominance * individual_dignity)\n\n    Args:\n        data (pd.Series): A single row of data as a pandas Series, containing the dimension scores.\n        **kwargs: Additional parameters (not used in this calculation).\n\n    Returns:\n        float: The calculated identity tension score, or None if the necessary\n               data is missing, non-numeric, or invalid (e.g., negative scores).\n    \"\"\"\n    import pandas as pd\n    import numpy as np\n\n    try:\n        # NOTE: Column names 'tribal_dominance' and 'individual_dignity' are inferred\n        # from the function's description, as per the instruction to use generic\n        # column names when no specific data structure is provided.\n        tribal_col = 'tribal_dominance'\n        dignity_col = 'individual_dignity'\n\n        # Use .get() to safely access data and avoid KeyErrors.\n        # pd.to_numeric handles conversion and coerces non-numeric values to NaN.\n        tribal_score = pd.to_numeric(data.get(tribal_col), errors='coerce')\n        dignity_score = pd.to_numeric(data.get(dignity_col), errors='coerce')\n\n        # Check if either score is missing (NaN) after extraction and conversion.\n        if pd.isna(tribal_score) or pd.isna(dignity_score):\n            return None\n\n        # The geometric mean is undefined for negative numbers in this context.\n        # Dimension scores are assumed to be non-negative.\n        if tribal_score < 0 or dignity_score < 0:\n            return None\n\n        # Calculate tension as the geometric mean of the two scores.\n        # This value is high only when both input scores are high.\n        tension = (tribal_score * dignity_score) ** 0.5\n\n        return float(tension)\n\n    except (AttributeError, TypeError, ValueError):\n        # Catch errors from invalid input types (e.g., data is not a Series)\n        # or other value-related issues not caught by the checks above.\n        return None\n    except Exception:\n        # A final catch-all for any other unexpected errors.\n        return None\n\ndef calculate_emotional_balance(data, **kwargs):\n    \"\"\"\n    Calculate emotional_balance: Difference between hope and fear scores\n\n    Formula: emotional_balance = hope - fear\n\n    Args:\n        data (pd.Series): A row of data containing score columns.\n        **kwargs: Additional keyword arguments (unused).\n\n    Returns:\n        float: The calculated emotional balance, or None if the necessary\n               data is missing or invalid.\n    \"\"\"\n    import pandas as pd\n    import numpy as np\n\n    try:\n        # Per instructions, using generic column names 'hope' and 'fear'\n        # as no specific data structure was provided.\n        hope_score = data['hope']\n        fear_score = data['fear']\n\n        # Ensure both values are present and are not NaN\n        if pd.isna(hope_score) or pd.isna(fear_score):\n            return None\n\n        # Calculate the difference and ensure the result is a float\n        balance = float(hope_score) - float(fear_score)\n        return balance\n\n    except (KeyError, TypeError, ValueError):\n        # KeyError: If 'hope' or 'fear' columns do not exist.\n        # TypeError/ValueError: If scores are not in a numeric format.\n        return None\n\ndef calculate_success_climate(data, **kwargs):\n    \"\"\"\n    Calculate success_climate: Difference between compersion and envy scores\n    Formula: compersion - envy\n    \n    Args:\n        data: pandas DataFrame with dimension scores\n        **kwargs: Additional parameters\n        \n    Returns:\n        float: Calculated result or None if insufficient data\n    \"\"\"\n    import pandas as pd\n    import numpy as np\n    \n    try:\n        # The column names 'compersion' and 'envy' are inferred from the description.\n        compersion_score = data['compersion']\n        envy_score = data['envy']\n        \n        # Check for missing data (NaN, None, etc.) before calculation.\n        if pd.isna(compersion_score) or pd.isna(envy_score):\n            return None\n            \n        # Calculate the difference, ensuring values are treated as floats.\n        result = float(compersion_score) - float(envy_score)\n        \n        # Ensure the result is a finite number (e.g., not infinity).\n        if not np.isfinite(result):\n            return None\n            \n        return result\n        \n    except Exception:\n        # A broad exception to catch any errors, such as missing columns (KeyError)\n        # or non-numeric data (TypeError/ValueError), and return None.\n        return None\n\ndef calculate_relational_climate(data, **kwargs):\n    \"\"\"\n    Calculate relational_climate: Difference between amity and enmity scores\n\n    Formula: relational_climate = amity - enmity\n\n    Args:\n        data (pd.Series): A single row of data as a pandas Series.\n        **kwargs: Additional parameters (unused).\n\n    Returns:\n        float: The calculated score, or None if essential data is missing.\n    \"\"\"\n    import pandas as pd\n    import numpy as np\n\n    try:\n        # Column names are inferred from the calculation description as no\n        # explicit data structure was provided.\n        amity_col = 'amity'\n        enmity_col = 'enmity'\n\n        amity_score = data[amity_col]\n        enmity_score = data[enmity_col]\n\n        # Check if either of the necessary component scores is null or NaN\n        if pd.isna(amity_score) or pd.isna(enmity_score):\n            return None\n\n        # Calculate the difference, ensuring inputs are numeric\n        result = float(amity_score) - float(enmity_score)\n        \n        # Ensure the final result is not NaN or infinite\n        if not np.isfinite(result):\n            return None\n\n        return result\n\n    except (KeyError, TypeError, ValueError):\n        # Handles cases where columns are missing or data is not numeric\n        return None\n    except Exception:\n        # A general catch-all for any other unexpected errors\n        return None\n\ndef calculate_goal_orientation(data, **kwargs):\n    \"\"\"\n    Calculate goal_orientation: Difference between cohesive goals and fragmentative goals\n\n    Formula: Goal Orientation = Cohesive Goals - Fragmentative Goals\n    \n    Args:\n        data (pd.Series): A pandas Series representing a single row of data.\n        **kwargs: Additional keyword arguments (not used).\n        \n    Returns:\n        float: Calculated result or None if insufficient data.\n    \"\"\"\n    import pandas as pd\n    import numpy as np\n    \n    # As per instructions, column names are inferred from the calculation description\n    # because no specific data structure was provided.\n    COHESIVE_COL = 'cohesive_goals'\n    FRAGMENTATIVE_COL = 'fragmentative_goals'\n    \n    try:\n        # Ensure the input has the required columns\n        if not all(col in data.index for col in [COHESIVE_COL, FRAGMENTATIVE_COL]):\n            return None\n\n        # Convert values to numeric, coercing errors to NaN\n        cohesive_score = pd.to_numeric(data[COHESIVE_COL], errors='coerce')\n        fragmentative_score = pd.to_numeric(data[FRAGMENTATIVE_COL], errors='coerce')\n\n        # Check if conversion resulted in NaN (due to missing or non-numeric values)\n        if pd.isna(cohesive_score) or pd.isna(fragmentative_score):\n            return None\n            \n        # Perform the calculation\n        result = float(cohesive_score - fragmentative_score)\n        \n        return result\n\n    except Exception:\n        # Catches any other error, such as if 'data' is not a compatible type.\n        return None\n\ndef calculate_overall_cohesion_index(data, **kwargs):\n    \"\"\"\n    Calculate overall_cohesion_index: Comprehensive measure combining all dimensions.\n\n    Formula (assumed based on framework description):\n    mean(\n        shared_identity_index,\n        institutional_trust_index,\n        constructive_engagement_index,\n        future_orientation_index\n    )\n    \n    Args:\n        data (pd.Series or pd.DataFrame): A single row of data as a pandas Series\n                                          or a one-row DataFrame.\n        **kwargs: Additional parameters (not used).\n        \n    Returns:\n        float: Calculated result or None if insufficient data.\n    \"\"\"\n    import pandas as pd\n    import numpy as np\n    \n    try:\n        # Per instructions, 'data' is a single row/Series. Handle if a DataFrame is passed.\n        if isinstance(data, pd.DataFrame):\n            if len(data) == 1:\n                # Convert single-row DataFrame to a Series for consistent processing\n                data = data.iloc[0]\n            else:\n                # This function is designed for a single record, not a multi-row DataFrame\n                return None\n        \n        # CRITICAL: The prompt provided conflicting instructions: to use EXACT column\n        # names but also stated \"No analysis data available\". Therefore, generic\n        # column names must be assumed based on the framework description.\n        # These names represent indices for social solidarity, trust, and engagement.\n        required_columns = [\n            'shared_identity_index',\n            'institutional_trust_index',\n            'constructive_engagement_index',\n            'future_orientation_index'\n        ]\n\n        # Check if all required columns are present in the data Series\n        if not all(col in data.index for col in required_columns):\n            return None\n\n        # Extract values for calculation\n        values = data[required_columns]\n\n        # Handle missing data gracefully by checking for NaN/None in the required values\n        if values.isnull().any():\n            return None\n\n        # The overall index is the mean of the component dimension indices,\n        # providing a balanced, comprehensive measure.\n        result = np.mean(values.astype(float))\n        \n        # Ensure the final output is a standard float or None\n        if pd.isna(result):\n            return None\n        return float(result)\n\n    except (AttributeError, KeyError, TypeError, ValueError):\n        # Return None for any data access or type conversion errors\n        return None\n\ndef calculate_all_derived_metrics(data: pd.DataFrame) -> Dict[str, Optional[float]]:\n    \"\"\"\n    Calculate all derived metrics for the given dataset.\n    \n    Args:\n        data: pandas DataFrame with dimension scores\n        \n    Returns:\n        Dictionary mapping metric names to calculated values\n    \"\"\"\n    results = {}\n    \n    # Get all calculation functions from this module\n    import inspect\n    current_module = inspect.getmodule(inspect.currentframe())\n    \n    for name, obj in inspect.getmembers(current_module):\n        if (inspect.isfunction(obj) and \n            name.startswith('calculate_') and \n            name not in ['calculate_all_derived_metrics', 'calculate_derived_metrics']):\n            try:\n                results[name.replace('calculate_', '')] = obj(data)\n            except Exception as e:\n                results[name.replace('calculate_', '')] = None\n                \n    return results\n\n\ndef calculate_derived_metrics(data: pd.DataFrame) -> pd.DataFrame:\n    \"\"\"\n    Template-compatible wrapper function for derived metrics calculation.\n    \n    This function is called by the universal notebook template and returns\n    the original data with additional derived metric columns.\n    \n    Args:\n        data: pandas DataFrame with dimension scores\n        \n    Returns:\n        DataFrame with original data plus derived metric columns\n    \"\"\"\n    # Calculate all derived metrics\n    derived_metrics = calculate_all_derived_metrics(data)\n    \n    # Create a copy of the original data\n    result = data.copy()\n    \n    # Add derived metrics as new columns\n    for metric_name, metric_value in derived_metrics.items():\n        if metric_value is not None:\n            # For scalar metrics, broadcast to all rows\n            result[metric_name] = metric_value\n        else:\n            # For failed calculations, use NaN\n            result[metric_name] = np.nan\n    \n    return result\n",
  "cached_with_code": true
}