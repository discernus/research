{
  "status": "success",
  "functions_generated": 6,
  "output_file": "automatedderivedmetricsagent_functions.py",
  "module_size": 13569,
  "function_code_content": "\"\"\"\nAutomated Derived Metrics Functions\n===================================\n\nGenerated by AutomatedDerivedMetricsAgent for experiment: Test Experiment\nDescription: Test experiment for derived metrics\nGenerated: 2025-08-27T17:42:50.688031+00:00\n\nThis module contains automatically generated calculation functions for derived metrics\nas specified in the framework's natural language descriptions.\n\"\"\"\n\nimport pandas as pd\nimport numpy as np\nfrom typing import Optional, Dict, Any\n\n\ndef calculate_identity_tension(data, **kwargs):\n    \"\"\"\n    Calculate identity_tension: Conflict between tribal dominance and individual dignity dimensions\n\n    Formula: tribal_dominance * individual_dignity\n    \n    Args:\n        data (pd.Series): A row of data, not used in this specific calculation.\n        **kwargs: Must contain a 'scores' dictionary with keys 'tribal_dominance'\n                  and 'individual_dignity'.\n        \n    Returns:\n        float: Calculated result or None if insufficient data.\n    \"\"\"\n    import pandas as pd\n    import numpy as np\n    \n    try:\n        # The required dimension scores are expected to be passed via kwargs,\n        # as the main data structure does not contain them.\n        scores = kwargs['scores']\n        \n        tribal_dominance = scores['tribal_dominance']\n        individual_dignity = scores['individual_dignity']\n\n        # Ensure that values are not None, NaN, etc. before calculation.\n        if pd.isna(tribal_dominance) or pd.isna(individual_dignity):\n            return None\n        \n        # Multiplication implies that tension is highest when both dimensions\n        # are strongly present. The float conversion will raise a TypeError\n        # for non-numeric types, which is handled below.\n        result = float(tribal_dominance) * float(individual_dignity)\n        \n        return result\n    except (KeyError, TypeError):\n        # This handles several common failure modes gracefully:\n        # - 'scores' key is missing in kwargs.\n        # - 'scores' is not a dictionary.\n        # - 'tribal_dominance' or 'individual_dignity' keys are missing in scores.\n        # - A score value is not a type that can be converted to a float (e.g., a string).\n        return None\n    except Exception:\n        # A general catch-all for any other unexpected errors ensures production stability.\n        return None\n\ndef calculate_emotional_balance(data, **kwargs):\n    \"\"\"\n    Calculate emotional_balance: Difference between hope and fear scores\n\n    Formula: hope - fear\n\n    Args:\n        data: A pandas Series representing a single row of data.\n        **kwargs: Additional keyword arguments (not used).\n\n    Returns:\n        float: Calculated result or None if insufficient data.\n    \"\"\"\n    import pandas as pd\n    import numpy as np\n\n    try:\n        # The calculation requires 'hope' and 'fear' scores.\n        # Accessing by key will raise a KeyError if the column is missing.\n        hope_score = data['hope']\n        fear_score = data['fear']\n\n        # Check if either score is null/NaN, which indicates missing data.\n        if pd.isna(hope_score) or pd.isna(fear_score):\n            return None\n\n        # Perform the calculation, ensuring the result is a standard float.\n        # This will raise a TypeError if the values are not numeric.\n        result = float(hope_score) - float(fear_score)\n\n        # A final check to ensure the result is a finite number (not inf or nan),\n        # which can occur in floating-point arithmetic.\n        if not np.isfinite(result):\n            return None\n\n        return result\n\n    except (KeyError, TypeError):\n        # Gracefully handle cases where:\n        # 1. 'hope' or 'fear' columns are not present in the data (KeyError).\n        # 2. The scores are not of a numeric type suitable for subtraction (TypeError).\n        return None\n\ndef calculate_success_climate(data, **kwargs):\n    \"\"\"\n    Calculate success_climate: Difference between compersion and envy scores\n    \n    Args:\n        data: pandas DataFrame with dimension scores\n        **kwargs: Additional parameters\n        \n    Returns:\n        float: Calculated result or None if insufficient data\n    \"\"\"\n    import pandas as pd\n    import numpy as np\n    \n    try:\n        # The calculation is defined as the difference between 'compersion' and 'envy'.\n        # We attempt to access these columns. The except block handles KeyErrors\n        # if they are not present, as suggested by the provided data structure.\n        compersion_score = data['compersion']\n        envy_score = data['envy']\n        \n        # Handle cases where columns exist but data is missing (NaN)\n        if pd.isna(compersion_score) or pd.isna(envy_score):\n            return None\n            \n        # Ensure values are numeric and perform the calculation\n        return float(compersion_score) - float(envy_score)\n        \n    except Exception:\n        # Catches any issue, including:\n        # - KeyError: if 'compersion' or 'envy' columns do not exist.\n        # - TypeError/ValueError: if data in columns is not numeric.\n        # - Any other unexpected error.\n        return None\n\ndef calculate_relational_climate(data, **kwargs):\n    \"\"\"\n    Calculate relational_climate: Difference between amity and enmity scores\n    \n    Formula: amity - enmity\n\n    Args:\n        data (pd.Series): A row of data from a pandas DataFrame.\n        **kwargs: Additional keyword arguments (not used).\n        \n    Returns:\n        float: The calculated result, or None if the necessary data is\n               missing or non-numeric.\n    \"\"\"\n    import pandas as pd\n    import numpy as np\n    \n    try:\n        # Access the required dimension scores from the data row (Series).\n        # A KeyError will be raised if 'amity' or 'enmity' columns do not exist.\n        amity_score = data['amity']\n        enmity_score = data['enmity']\n        \n        # Gracefully handle missing data (NaN, None) for either score.\n        if pd.isna(amity_score) or pd.isna(enmity_score):\n            return None\n            \n        # Calculate the difference, ensuring the values are treated as floats.\n        # A TypeError or ValueError will be raised if values are not numeric.\n        result = float(amity_score) - float(enmity_score)\n        \n        return result\n        \n    except (KeyError, TypeError, ValueError):\n        # If required columns are missing or data is not of a numeric type,\n        # the calculation cannot be performed. Return None as required.\n        return None\n    except Exception:\n        # A final catch-all for any other unexpected errors.\n        return None\n\ndef calculate_goal_orientation(data, **kwargs):\n    \"\"\"\n    Calculate goal_orientation: Difference between cohesive goals and fragmentative goals\n\n    Formula: goal_orientation = cohesive_goals - fragmentative_goals\n    \n    Args:\n        data (pd.Series): A single row of data from a pandas DataFrame.\n        **kwargs: Additional parameters (unused).\n        \n    Returns:\n        float: The calculated result, or None if data is missing or invalid.\n    \"\"\"\n    import pandas as pd\n    import numpy as np\n    \n    try:\n        # This calculation's description requires 'cohesive_goals' and \n        # 'fragmentative_goals' columns, which are assumed to exist in the data.\n        cohesive_score = data['cohesive_goals']\n        fragmentative_score = data['fragmentative_goals']\n\n        # Ensure inputs are numeric and not null before calculation\n        if pd.isna(cohesive_score) or pd.isna(fragmentative_score):\n            return None\n\n        # Calculate the difference\n        result = float(cohesive_score) - float(fragmentative_score)\n        \n        # A final check to ensure the result is not NaN\n        if np.isnan(result):\n            return None\n            \n        return result\n\n    except (KeyError, TypeError, ValueError):\n        # This handles cases where columns are missing or data is not convertible.\n        return None\n    except Exception:\n        # A general catch-all for any other unexpected errors.\n        return None\n\ndef calculate_overall_cohesion_index(data, **kwargs):\n    \"\"\"\n    Calculate overall_cohesion_index: Comprehensive measure combining all dimensions.\n\n    This function computes a composite index representing the overall level of social\n    cohesion in a document, based on the principles of the Cohesive Flourishing\n    Framework (CFF). It balances pro-cohesive dimensions against anti-cohesive ones.\n\n    Formula:\n    1. Identify pro-cohesion and anti-cohesion dimensions.\n       - Pro-Cohesion = [hope, trust, solidarity, engagement]\n       - Anti-Cohesion = [fear, distrust, fragmentation, cynicism]\n    2. Calculate the mean score for each group, ignoring missing values.\n       - Mean_Pro = mean(scores of Pro-Cohesion dimensions)\n       - Mean_Anti = mean(scores of Anti-Cohesion dimensions)\n    3. The final index is the difference between the two means.\n       - OCI = Mean_Pro - Mean_Anti\n\n    Note on Data Structure:\n    This calculation requires columns corresponding to the CFF dimensions (e.g., 'hope',\n    'fear'). These column names are inferred from the CFF framework description. The function\n    is designed to be robust and will return None if these specific columns are not\n    found in the input data, thus gracefully handling the provided data structure which\n    lacks these dimensional scores.\n\n    Args:\n        data (pd.Series or pd.DataFrame): A single row of analysis data containing\n                                          the required dimension scores.\n        **kwargs: Additional parameters (unused).\n\n    Returns:\n        float: The calculated Overall Cohesion Index, typically ranging from -1.0 to 1.0.\n               Returns None if the required dimension columns are not present or if\n               there are no valid scores to compute the index.\n    \"\"\"\n    import pandas as pd\n    import numpy as np\n\n    try:\n        # Define the column names for dimensions based on the CFF description.\n        # These are the required inputs for the calculation.\n        pro_cohesion_cols = ['hope', 'trust', 'solidarity', 'engagement']\n        anti_cohesion_cols = ['fear', 'distrust', 'fragmentation', 'cynicism']\n        required_cols = pro_cohesion_cols + anti_cohesion_cols\n\n        # The function expects a single row (as a pandas Series).\n        # If a DataFrame is passed, ensure it's a single row and convert to a Series.\n        if isinstance(data, pd.DataFrame):\n            if data.shape[0] != 1:\n                return None  # Cannot process multi-row DataFrame\n            row = data.iloc[0]\n        else:\n            row = data\n\n        # Verify that all required dimension columns exist in the data.\n        if not all(col in row.index for col in required_cols):\n            return None\n\n        # Extract scores for each group. The .mean() method automatically handles NaNs.\n        pro_scores = pd.to_numeric(row[pro_cohesion_cols], errors='coerce')\n        anti_scores = pd.to_numeric(row[anti_cohesion_cols], errors='coerce')\n\n        # Ensure there's at least one valid score in each group to calculate a mean.\n        if pro_scores.count() == 0 or anti_scores.count() == 0:\n            return None\n\n        mean_pro_cohesion = pro_scores.mean()\n        mean_anti_cohesion = anti_scores.mean()\n\n        # The final index is the balance between positive and negative forces.\n        overall_index = mean_pro_cohesion - mean_anti_cohesion\n\n        return float(overall_index)\n\n    except (AttributeError, KeyError, TypeError, ValueError):\n        # Catch potential errors from data manipulation if input is malformed.\n        return None\n\ndef calculate_all_derived_metrics(data: pd.DataFrame) -> Dict[str, Optional[float]]:\n    \"\"\"\n    Calculate all derived metrics for the given dataset.\n    \n    Args:\n        data: pandas DataFrame with dimension scores\n        \n    Returns:\n        Dictionary mapping metric names to calculated values\n    \"\"\"\n    results = {}\n    \n    # Get all calculation functions from this module\n    import inspect\n    current_module = inspect.getmodule(inspect.currentframe())\n    \n    for name, obj in inspect.getmembers(current_module):\n        if (inspect.isfunction(obj) and \n            name.startswith('calculate_') and \n            name not in ['calculate_all_derived_metrics', 'calculate_derived_metrics']):\n            try:\n                results[name.replace('calculate_', '')] = obj(data)\n            except Exception as e:\n                results[name.replace('calculate_', '')] = None\n                \n    return results\n\n\ndef calculate_derived_metrics(data: pd.DataFrame) -> pd.DataFrame:\n    \"\"\"\n    Template-compatible wrapper function for derived metrics calculation.\n    \n    This function is called by the universal notebook template and returns\n    the original data with additional derived metric columns.\n    \n    Args:\n        data: pandas DataFrame with dimension scores\n        \n    Returns:\n        DataFrame with original data plus derived metric columns\n    \"\"\"\n    # Calculate all derived metrics\n    derived_metrics = calculate_all_derived_metrics(data)\n    \n    # Create a copy of the original data\n    result = data.copy()\n    \n    # Add derived metrics as new columns\n    for metric_name, metric_value in derived_metrics.items():\n        if metric_value is not None:\n            # For scalar metrics, broadcast to all rows\n            result[metric_name] = metric_value\n        else:\n            # For failed calculations, use NaN\n            result[metric_name] = np.nan\n    \n    return result\n",
  "cached_with_code": true
}