{
  "status": "success",
  "functions_generated": 6,
  "output_file": "automatedderivedmetricsagent_functions.py",
  "module_size": 12493,
  "function_code_content": "\"\"\"\nAutomated Derived Metrics Functions\n===================================\n\nGenerated by AutomatedDerivedMetricsAgent for experiment: Test Experiment\nDescription: Test experiment for derived metrics\nGenerated: 2025-08-24T21:08:51.895181+00:00\n\nThis module contains automatically generated calculation functions for derived metrics\nas specified in the framework's natural language descriptions.\n\"\"\"\n\nimport pandas as pd\nimport numpy as np\nfrom typing import Optional, Dict, Any\n\n\ndef calculate_identity_tension(data, **kwargs):\n    \"\"\"\n    Calculate identity_tension: Conflict between tribal dominance and individual dignity dimensions.\n\n    This metric quantifies the tension that arises when a text simultaneously invokes appeals\n    to both group-based dominance and individual human dignity. A high score suggests a\n    complex or conflicted rhetorical strategy. The calculation models this as the\n    interaction between the two dimension scores.\n\n    Formula: tribal_dominance * individual_dignity\n\n    Args:\n        data (pd.Series): A single row of data (as a Series) containing dimension scores.\n        **kwargs: Additional keyword arguments (unused).\n\n    Returns:\n        float: The calculated identity tension score. Returns None if required data is\n               missing or invalid.\n    \"\"\"\n    import pandas as pd\n    import numpy as np\n\n    try:\n        # Column names are derived from the calculation's description as no explicit\n        # schema was provided in the prompt.\n        tribal_dominance_col = 'tribal_dominance'\n        individual_dignity_col = 'individual_dignity'\n\n        tribal_dominance = data[tribal_dominance_col]\n        individual_dignity = data[individual_dignity_col]\n\n        # Ensure both values are valid numbers before calculation.\n        if pd.isna(tribal_dominance) or pd.isna(individual_dignity):\n            return None\n\n        # The product of the two scores models their interaction, or \"tension\".\n        # This value is high only when both dimensions are strongly present.\n        result = float(tribal_dominance) * float(individual_dignity)\n\n        # Ensure the final result is a standard Python float.\n        return float(result)\n\n    except (KeyError, TypeError, ValueError):\n        # KeyError: A required column is missing.\n        # TypeError: A value is not of a numeric type for the operation.\n        # ValueError: A value cannot be converted to a float.\n        return None\n\ndef calculate_emotional_balance(data, **kwargs):\n    \"\"\"\n    Calculate emotional_balance: Difference between hope and fear scores\n\n    Formula: hope - fear\n\n    Args:\n        data (pd.Series): A single row of data represented as a pandas Series.\n        **kwargs: Additional parameters (unused).\n\n    Returns:\n        float: Calculated result or None if insufficient data.\n    \"\"\"\n    import pandas as pd\n    import numpy as np\n\n    try:\n        # Define the column names based on the calculation description\n        hope_col = 'hope'\n        fear_col = 'fear'\n\n        # Extract scores directly. A KeyError will be caught if columns are missing.\n        hope_score = data[hope_col]\n        fear_score = data[fear_col]\n        \n        # Check if either score is null/NaN before calculation\n        if pd.isna(hope_score) or pd.isna(fear_score):\n            return None\n\n        # Perform the calculation\n        # The values are cast to float to ensure consistent output type\n        result = float(hope_score) - float(fear_score)\n\n        # Final check to ensure the result is not NaN, which could occur\n        # with certain non-standard numeric types.\n        if np.isnan(result):\n            return None\n\n        return result\n    except (KeyError, TypeError, ValueError):\n        # KeyError: One of the required columns is not in the data.\n        # TypeError: Data in a column is not of a numeric type.\n        # ValueError: Data cannot be cast to float.\n        return None\n    except Exception:\n        # Catch-all for any other unexpected errors\n        return None\n\ndef calculate_success_climate(data, **kwargs):\n    \"\"\"\n    Calculate success_climate: Difference between compersion and envy scores\n\n    Formula: success_climate = compersion - envy\n\n    Args:\n        data (pd.Series): A single row of data from the DataFrame containing\n                          'compersion' and 'envy' scores.\n        **kwargs: Additional keyword arguments (not used).\n\n    Returns:\n        float: The calculated difference, or None if the necessary data\n               is missing, not numeric, or an error occurs.\n    \"\"\"\n    import pandas as pd\n    import numpy as np\n\n    try:\n        # Based on the calculation description, the required columns are inferred\n        # to be 'compersion' and 'envy'.\n\n        # Convert to numeric, coercing any non-numeric values to NaN. This also\n        # handles if the original data is already numeric.\n        compersion_score = pd.to_numeric(data['compersion'], errors='coerce')\n        envy_score = pd.to_numeric(data['envy'], errors='coerce')\n\n        # Check if either value is NaN (which occurs if data was missing,\n        # None, or non-numeric)\n        if pd.isna(compersion_score) or pd.isna(envy_score):\n            return None\n\n        # Calculate the difference and ensure the result is a standard float\n        result = float(compersion_score - envy_score)\n        return result\n\n    except (KeyError, TypeError, ValueError):\n        # A KeyError will be raised if 'compersion' or 'envy' columns are missing.\n        # A TypeError or ValueError could occur with incompatible data formats\n        # not handled by pd.to_numeric.\n        return None\n    except Exception:\n        # A general exception handler for any other unforeseen errors.\n        return None\n\ndef calculate_relational_climate(data, **kwargs):\n    \"\"\"\n    Calculate relational_climate: Difference between amity and enmity scores\n\n    Formula: relational_climate = amity - enmity\n\n    Args:\n        data (pd.Series): A single row of data from a pandas DataFrame.\n        **kwargs: Additional parameters (not used in this calculation).\n\n    Returns:\n        float: The calculated relational climate score, or None if necessary data is missing or invalid.\n    \"\"\"\n    import pandas as pd\n\n    try:\n        # The calculation requires 'amity' and 'enmity' scores.\n        # As per standard practice, these are assumed to be column names.\n        amity_score = data['amity']\n        enmity_score = data['enmity']\n\n        # Handle cases where data is missing (e.g., None, NaN)\n        if pd.isna(amity_score) or pd.isna(enmity_score):\n            return None\n\n        # Perform the calculation and return the result\n        return float(amity_score) - float(enmity_score)\n\n    except (KeyError, TypeError, ValueError):\n        # Handles missing columns ('amity', 'enmity') or non-numeric data.\n        return None\n    except Exception:\n        # A general catch-all for any other unexpected errors.\n        return None\n\ndef calculate_goal_orientation(data, **kwargs):\n    \"\"\"\n    Calculate goal_orientation: Difference between cohesive goals and fragmentative goals\n\n    Formula: cohesive_goals - fragmentative_goals\n    \n    Args:\n        data: pandas DataFrame with dimension scores\n        **kwargs: Additional parameters\n        \n    Returns:\n        float: Calculated result or None if insufficient data\n    \"\"\"\n    import pandas as pd\n    import numpy as np\n    \n    try:\n        # Since no explicit column names are provided, we infer them from the description.\n        cohesive_col = 'cohesive_goals'\n        fragmentative_col = 'fragmentative_goals'\n        \n        # Use .get() to safely access values, returning None if a column is missing.\n        cohesive_score = data.get(cohesive_col)\n        fragmentative_score = data.get(fragmentative_col)\n        \n        # pd.isna() is a robust way to check for missing values (None or np.nan).\n        # If either required value is missing, the calculation cannot proceed.\n        if pd.isna(cohesive_score) or pd.isna(fragmentative_score):\n            return None\n        \n        # Perform the calculation and ensure the result is a float.\n        return float(cohesive_score - fragmentative_score)\n\n    except Exception:\n        # Return None if any error occurs during the process (e.g., non-numeric types).\n        return None\n\ndef calculate_overall_cohesion_index(data, **kwargs):\n    \"\"\"\n    Calculate overall_cohesion_index: Comprehensive measure combining all dimensions.\n\n    This index provides a holistic score of cohesive flourishing by averaging key\n    sub-indices of the framework. As specific column names were not provided in the\n    prompt's data structure, this function assumes the existence of logical high-level\n    component indices based on the framework's description:\n    - 'social_capital_index'\n    - 'democratic_health_index'\n    - 'discourse_quality_index'\n\n    Formula:\n    overall_cohesion_index = MEAN(social_capital_index, democratic_health_index, discourse_quality_index)\n\n    Args:\n        data (pd.Series or pd.DataFrame): A single row/record of data as a pandas Series\n                                         or a single-row DataFrame.\n        **kwargs: Additional keyword arguments (not used).\n\n    Returns:\n        float: The calculated overall cohesion index, or None if any required\n               component index is missing or non-numeric.\n    \"\"\"\n    import pandas as pd\n    import numpy as np\n\n    # Based on the framework's goals, we assume the overall index is an aggregation\n    # of several high-level component indices.\n    component_indices = [\n        'social_capital_index',\n        'democratic_health_index',\n        'discourse_quality_index'\n    ]\n\n    try:\n        # Handle if a single-row DataFrame is passed instead of a Series\n        if isinstance(data, pd.DataFrame):\n            if len(data) != 1:\n                return None  # Cannot process multi-row DataFrame\n            data = data.iloc[0]\n\n        # Extract values for the component indices\n        values = [data[col] for col in component_indices]\n\n        # Ensure all values are present and numeric before calculation\n        if any(pd.isna(v) for v in values):\n            return None\n\n        # Calculate the mean of the component indices\n        result = np.mean(values)\n\n        return float(result)\n\n    except (KeyError, TypeError, ValueError, IndexError):\n        # KeyError: A required column is missing.\n        # TypeError/ValueError: A value is not numeric.\n        # IndexError: DataFrame passed was empty.\n        return None\n\ndef calculate_all_derived_metrics(data: pd.DataFrame) -> Dict[str, Optional[float]]:\n    \"\"\"\n    Calculate all derived metrics for the given dataset.\n    \n    Args:\n        data: pandas DataFrame with dimension scores\n        \n    Returns:\n        Dictionary mapping metric names to calculated values\n    \"\"\"\n    results = {}\n    \n    # Get all calculation functions from this module\n    import inspect\n    current_module = inspect.getmodule(inspect.currentframe())\n    \n    for name, obj in inspect.getmembers(current_module):\n        if (inspect.isfunction(obj) and \n            name.startswith('calculate_') and \n            name not in ['calculate_all_derived_metrics', 'calculate_derived_metrics']):\n            try:\n                results[name.replace('calculate_', '')] = obj(data)\n            except Exception as e:\n                results[name.replace('calculate_', '')] = None\n                \n    return results\n\n\ndef calculate_derived_metrics(data: pd.DataFrame) -> pd.DataFrame:\n    \"\"\"\n    Template-compatible wrapper function for derived metrics calculation.\n    \n    This function is called by the universal notebook template and returns\n    the original data with additional derived metric columns.\n    \n    Args:\n        data: pandas DataFrame with dimension scores\n        \n    Returns:\n        DataFrame with original data plus derived metric columns\n    \"\"\"\n    # Calculate all derived metrics\n    derived_metrics = calculate_all_derived_metrics(data)\n    \n    # Create a copy of the original data\n    result = data.copy()\n    \n    # Add derived metrics as new columns\n    for metric_name, metric_value in derived_metrics.items():\n        if metric_value is not None:\n            # For scalar metrics, broadcast to all rows\n            result[metric_name] = metric_value\n        else:\n            # For failed calculations, use NaN\n            result[metric_name] = np.nan\n    \n    return result\n",
  "cached_with_code": true
}