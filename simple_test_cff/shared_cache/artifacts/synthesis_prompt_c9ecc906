You are conducting a comprehensive computational social science analysis. Your task is to produce an academic-quality research report that extracts maximum insights from the provided data.

# RESEARCH CONTEXT

**Experiment Metadata:**
**Experiment Metadata**: Available in experiment configuration

**Framework Specification:**
# Cohesive Flourishing Framework (CFF) v10.0

---

## Part 1: The Scholarly Document

### Section 1: Abstract & *Raison d'Ãªtre*

**What is this framework?**
The Cohesive Flourishing Framework (CFF) is a comprehensive tool for analyzing political and social discourse to understand its impact on community cohesion and democratic health. It moves beyond simple sentiment analysis to reveal sophisticated patterns in how language builds or undermines social solidarity, trust, and constructive civic engagement.

**What problem does it solve?**
CFF addresses a critical gap in discourse analysis by providing a methodology that preserves complex rhetorical information. Traditional analysis often forces artificial choices (e.g., a text is "hopeful" or "fearful"), losing nuance when sophisticated communication employs competing appeals simultaneously. CFF's independent scoring of opposing dimensions (e.g., Hope vs. Fear) captures this complexity, enabling a more accurate and insightful analysis of...

**Experiment Configuration:**
Research objectives not specified.

**Complete Research Data:**
Complete Statistical Results (format into Markdown tables as instructed):
{
  "status": "completed",
  "stats_hash": "63603c000acefe505308f7b9f2e3c9d029672991bc1553296f97af824f3add86",
  "functions_generated": 3,
  "statistical_results": {
    "generation_metadata": {
      "status": "success",
      "functions_generated": 3,
      "output_file": "automatedstatisticalanalysisagent_functions.py",
      "module_size": 18831,
      "function_code_content": "\"\"\"\nAutomated Statistical Analysis Functions\n========================================\n\nGenerated by AutomatedStatisticalAnalysisAgent for experiment: simple_test\nDescription: Statistical analysis experiment\nGenerated: 2025-08-23T19:25:48.867355+00:00\n\nThis module contains automatically generated statistical analysis functions\nfor comprehensive data analysis including ANOVA, correlations, reliability,\nand hypothesis testing as appropriate for the research questions.\n\"\"\"\n\nimport pandas as pd\nimport numpy as np\nimport scipy.stats as stats\nfrom typing import Dict, Any, Optional, List, Tuple\nimport warnings\n\n# Suppress common statistical warnings for cleaner output\nwarnings.filterwarnings('ignore', category=RuntimeWarning)\n\n\ndef calculate_descriptive_statistics(data, **kwargs):\n    \"\"\"\n    Calculates descriptive statistics for all raw and salience scores from the CFF analysis.\n\n    This function provides a baseline understanding of the corpus by summarizing the central\n    tendency and dispersion of each primary dimension's intensity (raw score) and\n    rhetorical prominence (salience). It computes the mean, standard deviation, count,\n    minimum, and maximum for each relevant column.\n\n    Args:\n        data (pd.DataFrame): A DataFrame containing the CFF analysis data, with columns\n                             following the specified `_raw` and `_salience` naming convention.\n        **kwargs: Additional keyword arguments (not used).\n\n    Returns:\n        dict: A nested dictionary where each key is a dimension's raw or salience score\n              and the value is a dictionary of its descriptive statistics. Returns None\n              if the input data is invalid or empty.\n    \"\"\"\n    import pandas as pd\n    import numpy as np\n    import json\n    import glob\n    from pathlib import Path\n\n    try:\n        if data is None or data.empty:\n            return None\n\n        results = {}\n        # Select only columns that represent raw scores or salience\n        score_columns = [col for col in data.columns if col.endswith('_raw') or col.endswith('_salience')]\n        \n        if not score_columns:\n            return {} # Return empty dict if no relevant columns found\n\n        numeric_df = data[score_columns].apply(pd.to_numeric, errors='coerce')\n\n        for col in numeric_df.columns:\n            if numeric_df[col].notna().sum() > 0:\n                results[col] = {\n                    'mean': float(numeric_df[col].mean()),\n                    'std': float(numeric_df[col].std()),\n                    'count': int(numeric_df[col].count()),\n                    'min': float(numeric_df[col].min()),\n                    '25%': float(numeric_df[col].quantile(0.25)),\n                    '50%': float(numeric_df[col].quantile(0.50)),\n                    '75%': float(numeric_df[col].quantile(0.75)),\n                    'max': float(numeric_df[col].max())\n                }\n        \n        return results\n\n    except Exception:\n        return None\n\ndef calculate_cff_derived_metrics(data, **kwargs):\n    \"\"\"\n    Calculates all derived metrics from the Cohesive Flourishing Framework v10.0.\n\n    This function implements the formulas for the framework's advanced metrics, including\n    Tension Indices, the Strategic Contradiction Index, and the three Salience-Weighted\n    Cohesion Indices. It processes the entire DataFrame to generate these metrics for each\n    document, providing a deeper layer of analysis beyond the raw scores.\n\n    Methodology:\n    - Tension Indices: Calculated using the formula `min(Score_A, Score_B) * |Salience_A - Salience_B|`\n      for each opposing pair, quantifying strategic rhetorical contradictions.\n    - Strategic Contradiction Index: The arithmetic mean of the five tension indices,\n      measuring overall message incoherence.\n    - Cohesion Indices: Salience-weighted scores normalized by the sum of relevant salience\n      values, ranging from -1.0 (fragmentative) to +1.0 (cohesive). An epsilon of 0.001\n      is added to the denominator to prevent division by zero.\n    - Note: The framework specifies 'compersion', but the provided data structure contains\n      'compassion'. This function uses the 'compassion' columns as a substitute to match\n      the actual data schema.\n\n    Args:\n        data (pd.DataFrame): A DataFrame with CFF raw and salience scores.\n        **kwargs: Additional keyword arguments (not used).\n\n    Returns:\n        pd.DataFrame: The original DataFrame with added columns for each derived metric.\n                      Returns None if required columns are missing or data is invalid.\n    \"\"\"\n    import pandas as pd\n    import numpy as np\n    import json\n    import glob\n    from pathlib import Path\n\n    try:\n        if data is None or data.empty:\n            return None\n\n        df = data.copy()\n\n        required_cols = [\n            'tribal_dominance_raw', 'tribal_dominance_salience', 'individual_dignity_raw', 'individual_dignity_salience',\n            'fear_raw', 'fear_salience', 'hope_raw', 'hope_salience', 'envy_raw', 'envy_salience',\n            'compassion_raw', 'compassion_salience', 'enmity_raw', 'enmity_salience', 'amity_raw', 'amity_salience',\n            'fragmentative_goals_raw', 'fragmentative_goals_salience', 'cohesive_goals_raw', 'cohesive_goals_salience'\n        ]\n\n        if not all(col in df.columns for col in required_cols):\n            # Log or handle missing columns appropriately\n            return None\n        \n        # Convert relevant columns to numeric, coercing errors\n        for col in required_cols:\n            df[col] = pd.to_numeric(df[col], errors='coerce')\n\n        # --- 1. Tension Indices ---\n        df['identity_tension'] = np.minimum(df['tribal_dominance_raw'], df['individual_dignity_raw']) * \\\n                                 abs(df['tribal_dominance_salience'] - df['individual_dignity_salience'])\n        df['emotional_tension'] = np.minimum(df['fear_raw'], df['hope_raw']) * \\\n                                  abs(df['fear_salience'] - df['hope_salience'])\n        # NOTE: Using 'compassion' columns as a substitute for the framework's 'compersion'\n        df['success_tension'] = np.minimum(df['envy_raw'], df['compassion_raw']) * \\\n                                abs(df['envy_salience'] - df['compassion_salience'])\n        df['relational_tension'] = np.minimum(df['enmity_raw'], df['amity_raw']) * \\\n                                   abs(df['enmity_salience'] - df['amity_salience'])\n        df['goal_tension'] = np.minimum(df['fragmentative_goals_raw'], df['cohesive_goals_raw']) * \\\n                             abs(df['fragmentative_goals_salience'] - df['cohesive_goals_salience'])\n\n        # --- 2. Strategic Contradiction Index ---\n        tension_cols = ['identity_tension', 'emotional_tension', 'success_tension', 'relational_tension', 'goal_tension']\n        df['strategic_contradiction_index'] = df[tension_cols].mean(axis=1)\n\n        # --- 3. Salience-Weighted Cohesion Indices ---\n        # Intermediate cohesion components\n        identity_comp = (df['individual_dignity_raw'] * df['individual_dignity_salience'] - df['tribal_dominance_raw'] * df['tribal_dominance_salience'])\n        emotional_comp = (df['hope_raw'] * df['hope_salience'] - df['fear_raw'] * df['fear_salience'])\n        success_comp = (df['compassion_raw'] * df['compassion_salience'] - df['envy_raw'] * df['envy_salience'])\n        relational_comp = (df['amity_raw'] * df['amity_salience'] - df['enmity_raw'] * df['enmity_salience'])\n        goal_comp = (df['cohesive_goals_raw'] * df['cohesive_goals_salience'] - df['fragmentative_goals_raw'] * df['fragmentative_goals_salience'])\n\n        # Salience totals for normalization\n        descriptive_salience_total = (df['hope_salience'] + df['fear_salience'] + df['compassion_salience'] + df['envy_salience'] + df['amity_salience'] + df['enmity_salience'])\n        motivational_salience_total = descriptive_salience_total + df['cohesive_goals_salience'] + df['fragmentative_goals_salience']\n        full_salience_total = motivational_salience_total + df['individual_dignity_salience'] + df['tribal_dominance_salience']\n        \n        epsilon = 0.001\n\n        # Final Cohesion Indices\n        df['descriptive_cohesion_index'] = (emotional_comp + success_comp + relational_comp) / (descriptive_salience_total + epsilon)\n        df['motivational_cohesion_index'] = (emotional_comp + success_comp + relational_comp + goal_comp) / (motivational_salience_total + epsilon)\n        df['full_cohesion_index'] = (identity_comp + emotional_comp + success_comp + relational_comp + goal_comp) / (full_salience_total + epsilon)\n\n        # Clip values to be strictly within [-1.0, 1.0] range to handle potential floating point inaccuracies\n        cohesion_indices = ['descriptive_cohesion_index', 'motivational_cohesion_index', 'full_cohesion_index']\n        for col in cohesion_indices:\n            df[col] = df[col].clip(-1.0, 1.0)\n\n        return df\n\n    except Exception:\n        return None\n\ndef summarize_derived_metrics(data, **kwargs):\n    \"\"\"\n    Calculates and summarizes the CFF derived metrics for the entire corpus.\n\n    This function first computes the derived metrics (tensions and cohesion indices) for\n    each document and then calculates descriptive statistics (mean, std, quartiles, etc.)\n    for these newly computed metrics. This provides a high-level overview of the corpus's\n    overall rhetorical patterns, answering questions about average cohesion, tension, and\n    strategic contradiction across all documents.\n\n    Args:\n        data (pd.DataFrame): A DataFrame with CFF raw and salience scores.\n        **kwargs: Additional keyword arguments (not used).\n\n    Returns:\n        dict: A nested dictionary of descriptive statistics for each derived metric.\n              Returns None if the input data is invalid or cannot be processed.\n    \"\"\"\n    import pandas as pd\n    import numpy as np\n    import json\n    import glob\n    from pathlib import Path\n\n    try:\n        # This function relies on the calculate_cff_derived_metrics logic.\n        # To maintain modularity, we define the calculation logic here again.\n        # In a real library, this would be a shared helper function.\n        \n        if data is None or data.empty:\n            return None\n\n        df = data.copy()\n\n        required_cols = [\n            'tribal_dominance_raw', 'tribal_dominance_salience', 'individual_dignity_raw', 'individual_dignity_salience',\n            'fear_raw', 'fear_salience', 'hope_raw', 'hope_salience', 'envy_raw', 'envy_salience',\n            'compassion_raw', 'compassion_salience', 'enmity_raw', 'enmity_salience', 'amity_raw', 'amity_salience',\n            'fragmentative_goals_raw', 'fragmentative_goals_salience', 'cohesive_goals_raw', 'cohesive_goals_salience'\n        ]\n\n        if not all(col in df.columns for col in required_cols):\n            return None\n        \n        for col in required_cols:\n            df[col] = pd.to_numeric(df[col], errors='coerce')\n\n        df['identity_tension'] = np.minimum(df['tribal_dominance_raw'], df['individual_dignity_raw']) * abs(df['tribal_dominance_salience'] - df['individual_dignity_salience'])\n        df['emotional_tension'] = np.minimum(df['fear_raw'], df['hope_raw']) * abs(df['fear_salience'] - df['hope_salience'])\n        df['success_tension'] = np.minimum(df['envy_raw'], df['compassion_raw']) * abs(df['envy_salience'] - df['compassion_salience'])\n        df['relational_tension'] = np.minimum(df['enmity_raw'], df['amity_raw']) * abs(df['enmity_salience'] - df['amity_salience'])\n        df['goal_tension'] = np.minimum(df['fragmentative_goals_raw'], df['cohesive_goals_raw']) * abs(df['fragmentative_goals_salience'] - df['cohesive_goals_salience'])\n        \n        tension_cols = ['identity_tension', 'emotional_tension', 'success_tension', 'relational_tension', 'goal_tension']\n        df['strategic_contradiction_index'] = df[tension_cols].mean(axis=1)\n\n        identity_comp = (df['individual_dignity_raw'] * df['individual_dignity_salience'] - df['tribal_dominance_raw'] * df['tribal_dominance_salience'])\n        emotional_comp = (df['hope_raw'] * df['hope_salience'] - df['fear_raw'] * df['fear_salience'])\n        success_comp = (df['compassion_raw'] * df['compassion_salience'] - df['envy_raw'] * df['envy_salience'])\n        relational_comp = (df['amity_raw'] * df['amity_salience'] - df['enmity_raw'] * df['enmity_salience'])\n        goal_comp = (df['cohesive_goals_raw'] * df['cohesive_goals_salience'] - df['fragmentative_goals_raw'] * df['fragmentative_goals_salience'])\n\n        descriptive_salience_total = (df['hope_salience'] + df['fear_salience'] + df['compassion_salience'] + df['envy_salience'] + df['amity_salience'] + df['enmity_salience'])\n        motivational_salience_total = descriptive_salience_total + df['cohesive_goals_salience'] + df['fragmentative_goals_salience']\n        full_salience_total = motivational_salience_total + df['individual_dignity_salience'] + df['tribal_dominance_salience']\n        \n        epsilon = 0.001\n        df['descriptive_cohesion_index'] = ((emotional_comp + success_comp + relational_comp) / (descriptive_salience_total + epsilon)).clip(-1.0, 1.0)\n        df['motivational_cohesion_index'] = ((emotional_comp + success_comp + relational_comp + goal_comp) / (motivational_salience_total + epsilon)).clip(-1.0, 1.0)\n        df['full_cohesion_index'] = ((identity_comp + emotional_comp + success_comp + relational_comp + goal_comp) / (full_salience_total + epsilon)).clip(-1.0, 1.0)\n\n        derived_metric_cols = tension_cols + ['strategic_contradiction_index', 'descriptive_cohesion_index', 'motivational_cohesion_index', 'full_cohesion_index']\n        \n        summary = {}\n        for col in derived_metric_cols:\n            if df[col].notna().sum() > 0:\n                summary[col] = {\n                    'mean': float(df[col].mean()),\n                    'std': float(df[col].std()),\n                    'count': int(df[col].count()),\n                    'min': float(df[col].min()),\n                    '25%': float(df[col].quantile(0.25)),\n                    '50%': float(df[col].quantile(0.50)),\n                    '75%': float(df[col].quantile(0.75)),\n                    'max': float(df[col].max())\n                }\n        return summary\n\n    except Exception:\n        return None\n\ndef run_complete_statistical_analysis(data: pd.DataFrame, alpha: float = 0.05) -> Dict[str, Any]:\n    \"\"\"\n    Run complete statistical analysis suite on the dataset.\n    \n    Args:\n        data: pandas DataFrame with dimension scores\n        alpha: Significance level for hypothesis tests (default: 0.05)\n        \n    Returns:\n        Dictionary with all statistical analysis results\n    \"\"\"\n    results = {\n        'analysis_metadata': {\n            'timestamp': pd.Timestamp.now().isoformat(),\n            'sample_size': len(data),\n            'alpha_level': alpha,\n            'variables_analyzed': list(data.select_dtypes(include=[np.number]).columns)\n        }\n    }\n    \n    # Get all analysis functions from this module\n    import inspect\n    current_module = inspect.getmodule(inspect.currentframe())\n    \n    for name, obj in inspect.getmembers(current_module):\n        if (inspect.isfunction(obj) and \n            name.startswith(('calculate_', 'perform_', 'test_')) and \n            name != 'run_complete_statistical_analysis'):\n            try:\n                # Pass alpha parameter to functions that might need it\n                if 'alpha' in inspect.signature(obj).parameters:\n                    results[name] = obj(data, alpha=alpha)\n                else:\n                    results[name] = obj(data)\n            except Exception as e:\n                results[name] = {'error': f'Analysis failed: {str(e)}'}\n                \n    return results\n\n\ndef perform_statistical_analysis(data: pd.DataFrame) -> Dict[str, Any]:\n    \"\"\"\n    Template-compatible wrapper function for statistical analysis.\n    \n    This function is called by the universal notebook template and performs\n    comprehensive statistical analysis on the provided dataset.\n    \n    Args:\n        data: pandas DataFrame with dimension scores and derived metrics\n        \n    Returns:\n        Dictionary containing all statistical analysis results\n    \"\"\"\n    return run_complete_statistical_analysis(data)\n\n\ndef generate_statistical_summary_report(analysis_results: Dict[str, Any]) -> str:\n    \"\"\"\n    Generate a human-readable summary report from statistical analysis results.\n    \n    Args:\n        analysis_results: Results from run_complete_statistical_analysis()\n        \n    Returns:\n        String containing formatted statistical report\n    \"\"\"\n    report_lines = []\n    report_lines.append(\"STATISTICAL ANALYSIS SUMMARY REPORT\")\n    report_lines.append(\"=\" * 50)\n    \n    metadata = analysis_results.get('analysis_metadata', {})\n    report_lines.append(f\"Analysis Timestamp: {metadata.get('timestamp', 'Unknown')}\")\n    report_lines.append(f\"Sample Size: {metadata.get('sample_size', 'Unknown')}\")\n    report_lines.append(f\"Alpha Level: {metadata.get('alpha_level', 'Unknown')}\")\n    report_lines.append(f\"Variables: {len(metadata.get('variables_analyzed', []))}\")\n    report_lines.append(\"\")\n    \n    # Summarize key findings\n    for analysis_name, result in analysis_results.items():\n        if analysis_name != 'analysis_metadata' and isinstance(result, dict):\n            if 'error' not in result:\n                report_lines.append(f\"{analysis_name.replace('_', ' ').title()}:\")\n                \n                # Extract key statistics based on analysis type\n                if 'p_value' in result:\n                    p_val = result['p_value']\n                    significance = \"significant\" if p_val < metadata.get('alpha_level', 0.05) else \"not significant\"\n                    report_lines.append(f\"  - p-value: {p_val:.4f} ({significance})\")\n                \n                if 'effect_size' in result:\n                    report_lines.append(f\"  - Effect size: {result['effect_size']:.4f}\")\n                \n                if 'correlation_matrix' in result:\n                    report_lines.append(f\"  - Correlation matrix generated with {len(result['correlation_matrix'])} variables\")\n                \n                if 'cronbach_alpha' in result:\n                    alpha_val = result['cronbach_alpha']\n                    reliability = \"excellent\" if alpha_val > 0.9 else \"good\" if alpha_val > 0.8 else \"acceptable\" if alpha_val > 0.7 else \"questionable\"\n                    report_lines.append(f\"  - Cronbach's \u03b1: {alpha_val:.3f} ({reliability})\")\n                \n                report_lines.append(\"\")\n            else:\n                report_lines.append(f\"{analysis_name}: ERROR - {result['error']}\")\n                report_lines.append(\"\")\n    \n    return \"\\n\".join(report_lines)\n",
      "cached_with_code": true
    },
    "statistical_data": {
      "calculate_cff_derived_metrics": null,
      "calculate_descriptive_statistics": {
        "tribal_dominance_raw": {
          "mean": 0.575,
          "std": 0.38622100754188227,
          "count": 4,
          "min": 0.0,
          "25%": 0.5249999999999999,
          "50%": 0.75,
          "75%": 0.8,
          "max": 0.8
        },
        "tribal_dominance_salience": {
          "mean": 0.675,
          "std": 0.38622100754188227,
          "count": 4,
          "min": 0.1,
          "25%": 0.625,
          "50%": 0.8500000000000001,
          "75%": 0.9,
          "max": 0.9
        },
        "individual_dignity_raw": {
          "mean": 0.45,
          "std": 0.4654746681256314,
          "count": 4,
          "min": 0.0,
          "25%": 0.07500000000000001,
          "50%": 0.45,
          "75%": 0.8250000000000001,
          "max": 0.9
        },
        "individual_dignity_salience": {
          "mean": 0.45,
          "std": 0.4654746681256314,
          "count": 4,
          "min": 0.0,
          "25%": 0.07500000000000001,
          "50%": 0.45,
          "75%": 0.8250000000000001,
          "max": 0.9
        },
        "fear_raw": {
          "mean": 0.625,
          "std": 0.35939764421413045,
          "count": 4,
          "min": 0.1,
          "25%": 0.5499999999999999,
          "50%": 0.75,
          "75%": 0.8250000000000001,
          "max": 0.9
        },
        "fear_salience": {
          "mean": 0.6875,
          "std": 0.32755406678389243,
          "count": 4,
          "min": 0.2,
          "25%": 0.65,
          "50%": 0.825,
          "75%": 0.8625,
          "max": 0.9
        },
        "hope_raw": {
          "mean": 0.425,
          "std": 0.29860788111948194,
          "count": 4,
          "min": 0.0,
          "25%": 0.375,
          "50%": 0.5,
          "75%": 0.55,
          "max": 0.7
        },
        "hope_salience": {
          "mean": 0.475,
          "std": 0.3403429642777023,
          "count": 4,
          "min": 0.0,
          "25%": 0.375,
          "50%": 0.55,
          "75%": 0.65,
          "max": 0.8
        },
        "envy_raw": {
          "mean": 0.575,
          "std": 0.42720018726587655,
          "count": 4,
          "min": 0.0,
          "25%": 0.375,
          "50%": 0.7,
          "75%": 0.9,
          "max": 0.9
        },
        "envy_salience": {
          "mean": 0.55,
          "std": 0.4358898943540674,
          "count": 4,
          "min": 0.0,
          "25%": 0.30000000000000004,
          "50%": 0.65,
          "75%": 0.9,
          "max": 0.9
        },
        "compersion_raw": {
          "mean": 0.225,
          "std": 0.45000000000000007,
          "count": 4,
          "min": 0.0,
          "25%": 0.0,
          "50%": 0.0,
          "75%": 0.225,
          "max": 0.9
        },
        "compersion_salience": {
          "mean": 0.225,
          "std": 0.45000000000000007,
          "count": 4,
          "min": 0.0,
          "25%": 0.0,
          "50%": 0.0,
          "75%": 0.225,
          "max": 0.9
        },
        "enmity_raw": {
          "mean": 0.65,
          "std": 0.4358898943540674,
          "count": 4,
          "min": 0.0,
          "25%": 0.6000000000000001,
          "50%": 0.8500000000000001,
          "75%": 0.9,
          "max": 0.9
        },
        "enmity_salience": {
          "mean": 0.6875,
          "std": 0.39660013447635983,
          "count": 4,
          "min": 0.1,
          "25%": 0.625,
          "50%": 0.8500000000000001,
          "75%": 0.9125,
          "max": 0.95
        },
        "amity_raw": {
          "mean": 0.55,
          "std": 0.40414518843273806,
          "count": 4,
          "min": 0.0,
          "25%": 0.375,
          "50%": 0.65,
          "75%": 0.8250000000000001,
          "max": 0.9
        },
        "amity_salience": {
          "mean": 0.5625,
          "std": 0.41907636535600523,
          "count": 4,
          "min": 0.0,
          "25%": 0.375,
          "50%": 0.65,
          "75%": 0.8375,
          "max": 0.95
        },
        "fragmentative_goals_raw": {
          "mean": 0.5875,
          "std": 0.39237524556645176,
          "count": 4,
          "min": 0.0,
          "25%": 0.5625,
          "50%": 0.775,
          "75%": 0.8,
          "max": 0.8
        },
        "fragmentative_goals_salience": {
          "mean": 0.55,
          "std": 0.3696845502136472,
          "count": 4,
          "min": 0.0,
          "25%": 0.5249999999999999,
          "50%": 0.7,
          "75%": 0.725,
          "max": 0.8
        },
        "cohesive_goals_raw": {
          "mean": 0.5625,
          "std": 0.41508031351374236,
          "count": 4,
          "min": 0.0,
          "25%": 0.375,
          "50%": 0.675,
          "75%": 0.8625,
          "max": 0.9
        },
        "cohesive_goals_salience": {
          "mean": 0.5625,
          "std": 0.4534589286804263,
          "count": 4,
          "min": 0.0,
          "25%": 0.30000000000000004,
          "50%": 0.625,
          "75%": 0.8875,
          "max": 1.0
        }
      },
      "generate_statistical_summary_report": "STATISTICAL ANALYSIS SUMMARY REPORT\n==================================================\nAnalysis Timestamp: Unknown\nSample Size: Unknown\nAlpha Level: Unknown\nVariables: 0\n",
      "perform_statistical_analysis": {
        "analysis_metadata": {
          "timestamp": "2025-08-23T20:58:03.607784",
          "sample_size": 4,
          "alpha_level": 0.05,
          "variables_analyzed": [
            "tribal_dominance_raw",
            "tribal_dominance_salience",
            "tribal_dominance_confidence",
            "individual_dignity_raw",
            "individual_dignity_salience",
            "individual_dignity_confidence",
            "fear_raw",
            "fear_salience",
            "fear_confidence",
            "hope_raw",
            "hope_salience",
            "hope_confidence",
            "envy_raw",
            "envy_salience",
            "envy_confidence",
            "compersion_raw",
            "compersion_salience",
            "compersion_confidence",
            "enmity_raw",
            "enmity_salience",
            "enmity_confidence",
            "amity_raw",
            "amity_salience",
            "amity_confidence",
            "fragmentative_goals_raw",
            "fragmentative_goals_salience",
            "fragmentative_goals_confidence",
            "cohesive_goals_raw",
            "cohesive_goals_salience",
            "cohesive_goals_confidence"
          ]
        }
      },
      "run_complete_statistical_analysis": {
        "analysis_metadata": {
          "timestamp": "2025-08-23T20:58:03.610404",
          "sample_size": 4,
          "alpha_level": 0.05,
          "variables_analyzed": [
            "tribal_dominance_raw",
            "tribal_dominance_salience",
            "tribal_dominance_confidence",
            "individual_dignity_raw",
            "individual_dignity_salience",
            "individual_dignity_confidence",
            "fear_raw",
            "fear_salience",
            "fear_confidence",
            "hope_raw",
            "hope_salience",
            "hope_confidence",
            "envy_raw",
            "envy_salience",
            "envy_confidence",
            "compersion_raw",
            "compersion_salience",
            "compersion_confidence",
            "enmity_raw",
            "enmity_salience",
            "enmity_confidence",
            "amity_raw",
            "amity_salience",
            "amity_confidence",
            "fragmentative_goals_raw",
            "fragmentative_goals_salience",
            "fragmentative_goals_confidence",
            "cohesive_goals_raw",
            "cohesive_goals_salience",
            "cohesive_goals_confidence"
          ]
        }
      },
      "summarize_derived_metrics": null
    },
    "status": "success_with_data",
    "validation_passed": true
  }
}

**Available Evidence for Citation:**
You have access to 936 pieces of textual evidence extracted during analysis. Use semantic queries to find relevant evidence for each statistical finding.

# ANALYTICAL REQUIREMENTS

## Level 1: Basic Statistical Interpretation
- Interpret descriptive statistics for all measured dimensions
- Identify patterns in means, standard deviations, and distributions
- Note significant correlations and their strength
- Assess measurement quality using framework-appropriate validation:
  * For oppositional frameworks: Interpret negative correlations as validation (opposing constructs should be negatively correlated)
  * For unidimensional frameworks: Interpret traditional reliability metrics (Cronbach's Alpha)

## Level 2: Advanced Pattern Recognition  
- Analyze cross-dimensional relationships and interaction effects
- Identify statistical outliers and anomalous patterns
- Examine confidence patterns and analytical uncertainty
- Detect framework-specific insights from derived metrics

## Level 3: Cross-Dimensional Network Analysis
- Map dimensional clustering and meta-strategies
- Identify universal patterns across all cases
- Analyze tension patterns and strategic contradictions
- Assess variance decomposition and discriminatory power

## Level 4: Temporal and Archetypal Analysis
- Examine temporal progression patterns (when applicable)
- Identify rhetorical archetypes and speaker clustering
- Analyze normative layer gradients and trajectories
- Assess framework effectiveness and limitations

## Level 5: Meta-Analysis and Theoretical Integration
- Connect findings to relevant theoretical frameworks
- Identify methodological implications and innovations
- Generate testable hypotheses for future research
- Assess broader implications for the field

# REPORT STRUCTURE REQUIREMENTS

## 0. Experiment Provenance Header (REQUIRED FIRST)
Start every report with available experiment metadata:

```
# [Framework Name] Analysis Report

**Experiment**: [experiment_name]  
**Run ID**: [run_id]  
**Date**: [completion_date]  
**Framework**: [framework_filename]  
**Corpus**: [corpus_filename] ([document_count] documents)  

---
```

Use only metadata that is actually available in the experiment_metadata. This header enables traceability of results.

## 1. Executive Summary (2-3 paragraphs)
- Key findings with statistical support
- Primary insights and their significance
- Framework effectiveness assessment

## 2. Opening Framework: Key Insights (Bullet points)
- 4-6 primary insights from the analysis
- Each supported by specific statistical evidence
- Clear, accessible language for broad audience

## 3. Literature Review and Theoretical Framework (Optional)
- Connect framework to relevant academic literature
- Position analysis within scholarly discourse
- Identify theoretical foundations

## 4. Methodology
- Framework description and analytical approach
- Data structure and corpus description
- Statistical methods and analytical constraints
- Acknowledge limitations and methodological choices

## 5. Comprehensive Results
### 5.1 Descriptive Statistics
- Present all statistical results in properly formatted Markdown tables
- Include significance indicators: * p<0.05, ** p<0.01, *** p<0.001
- Add effect size interpretations (Small/Medium/Large based on Cohen's conventions)
- Use consistent decimal precision (2-3 places)
- Dimensional means, distributions, and patterns with statistical interpretation

### 5.2 Advanced Metric Analysis
- Derived metrics interpretation
- Tension patterns and strategic contradictions
- Confidence-weighted analysis

### 5.3 Correlation and Interaction Analysis
- Cross-dimensional relationships with theoretical interpretation
- Network effects and clustering patterns
- Meta-strategy identification

### 5.4 Pattern Recognition and Theoretical Insights
- Identify the strongest correlations and explain their practical significance
- Connect statistical patterns to theoretical frameworks and literature
- Explain what correlation patterns reveal about the framework's construct validity
- Highlight unexpected findings and their implications
- Assess framework-corpus fit based on statistical patterns

### 5.5 Framework Effectiveness Assessment
- Discriminatory power analysis
- Framework-corpus fit evaluation
- Methodological insights

## 6. Discussion
- Theoretical implications of findings
- Comparative analysis and archetypal patterns
- Broader significance for the field
- Limitations and future directions

## 7. Conclusion
- Summary of key contributions
- Methodological validation
- Research implications

## 8. Evidence Citations
- Complete attribution for all quoted evidence
- Organized by source document
- Substantial quotes with context

# CRITICAL REQUIREMENTS

## Evidence Integration Standards
- **Every major claim** must include both statistical evidence AND textual quotes
- **Attribution format**: 'As [Speaker] stated: "[exact quote]" (Source: [document_name])'
- **Substantial quotes**: Full sentences, not fragments
- **Quality check**: Every Results paragraph contains at least one direct quote

## Statistical Interpretation Standards
- **No calculations**: Interpret provided statistics as definitive facts
- **Transparency**: State analytical approach clearly (descriptive vs. inferential)
- **Appropriate conclusions**: Draw strongest evidence-based conclusions possible
- **Uncertainty acknowledgment**: Note limitations while maximizing insights

## Framework Agnosticism Standards
- **Dynamic adaptation**: Work with any framework's dimensional structure
- **No assumptions**: Don't assume specific dimension names or relationships
- **Flexible analysis**: Adapt analytical depth to available data richness
- **Universal patterns**: Look for insights applicable across frameworks

## Academic Quality Standards
- **Publication-ready**: Suitable for peer-reviewed journal submission
- **Methodological rigor**: Clear methodology and limitation acknowledgment
- **Theoretical grounding**: Connect to relevant academic literature when possible
- **Reproducible insights**: Clear connection from data through analysis to conclusions

# OUTPUT INSTRUCTIONS

Generate a comprehensive academic report following the structure above. Use the complete research data and evidence to extract maximum insights while maintaining scientific rigor. The report should demonstrate the analytical sophistication possible through computational social science methods.

**Target Length**: 3000-5000 words for comprehensive analysis
**Writing Style**: Academic but accessible, suitable for computational social science journals
**Evidence Integration**: Seamless weaving of statistical and textual evidence throughout
